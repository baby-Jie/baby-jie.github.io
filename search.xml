<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux：前后台进程管理</title>
      <link href="/2022/06/26/linux%EF%BC%9A%E5%89%8D%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2022/06/26/linux%EF%BC%9A%E5%89%8D%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="linux：前后台进程管理"><a href="#linux：前后台进程管理" class="headerlink" title="linux：前后台进程管理"></a>linux：前后台进程管理</h1><h2 id="以-amp-结尾"><a href="#以-amp-结尾" class="headerlink" title="以 &amp; 结尾"></a>以 &amp; 结尾</h2><ul><li><p>首先执行一个命令 <code>sleept 1234</code>, 你会发现，终端将被这个命令阻塞住，这个时候，该命令执行的进程是前台进程，想要不阻塞终端去执行该命令，可以以 <code>&amp;</code> 结尾。然后以 <code>ps aux | grep sleep</code> 去查找该后台进程</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sleep 1234 &amp;</span></span><br><span class="line">[1] 11549</span><br><span class="line"><span class="comment"># ps aux | grep sleep</span></span><br><span class="line">root     11549  0.0  0.0 108056   360 pts/30   S    14:31   0:00 <span class="built_in">sleep</span> 1234</span><br><span class="line">root     11590  0.0  0.0 112816   980 pts/30   S+   14:31   0:00 grep --color=auto <span class="built_in">sleep</span></span><br><span class="line">root     19765  0.0  0.6 1026500 11448 ?       Sl   Jun23   1:03 /bin/sh -c <span class="built_in">sleep</span> 100</span><br></pre></td></tr></tbody></table></figure></li><li><p>但是，如果我们关闭了终端，那么该后台进程将也会被关闭，所以如果我们需要关闭终端不关闭进程的特性，那我们需要用到 <strong>nohup</strong> 命令</p></li></ul><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><ul><li><p><code>nohup sleep 12345 &amp;</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nohup sleep 1111 &amp; </span></span><br><span class="line">[1] 12910</span><br><span class="line"><span class="built_in">nohup</span>: ignoring input and appending output to ‘nohup.out’</span><br></pre></td></tr></tbody></table></figure><ul><li>终端关闭再次打开后，使用<code>ps aux | grep sleep</code> 发现该进程依旧存在</li><li>注意，该进程将忽略标准输入，并且将标准输出重定向到 <strong>nohup.out</strong> 文本文件中</li></ul></li></ul><h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><ul><li>虚拟终端管理器</li><li>管理命令:<ul><li>创建一个虚拟终端: <code>screen -S name</code> (如果已经存在同名的虚拟终端，依旧创建)</li><li>创建一个虚拟终端或者切换到一个已经存在的虚拟终端: <code>screen -R name</code> 如果name 不存在，则创建，存在则切换。更加实用</li><li>退出虚拟终端：<kbd>Ctrl</kbd> + <kbd>A</kbd> + <kbd>D</kbd></li><li>查看虚拟终端列表: <code>screen -list</code></li><li>关闭释放虚拟终端: <code>exit</code></li></ul></li><li>一般用来以前台方式执行阻塞程序<ul><li>执行spring boot 程序：开启虚拟终端，执行，退出虚拟终端，等到不用这个程序的时候关闭这个虚拟终端即可</li></ul></li><li>即使终端关闭再打开，虚拟终端还是存在的</li></ul><h2 id="后台进程管理"><a href="#后台进程管理" class="headerlink" title="后台进程管理"></a>后台进程管理</h2><ul><li><p>命令:</p><ul><li><code>jobs</code>: 查看后台进程</li><li><code>bg</code>: 将前台进程转换成后台进程</li><li><code>fg</code>: 将后台进程转为前台进程</li></ul></li><li><p>先运行命令 <code>sleep 1234</code>，这时是以前台方式运行，阻塞住终端，按下<code>Ctrl + Z</code> 挂起进程，可以在 <code>jobs</code> 和 <code>ps aux | grep sleep</code> 中看到该进程</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sleep 1234 </span></span><br><span class="line">^Z</span><br><span class="line">[1]+  Stopped                 <span class="built_in">sleep</span> 1234</span><br><span class="line"><span class="comment"># ps aux | grep sleep</span></span><br><span class="line">root     22685  0.0  0.0 108056   360 pts/32   T    15:12   0:00 <span class="built_in">sleep</span> 1234</span><br><span class="line">root     22708  0.0  0.0 112812   980 pts/32   S+   15:12   0:00 grep --color=auto <span class="built_in">sleep</span></span><br><span class="line"><span class="comment"># jobs</span></span><br><span class="line">[1]+  Stopped                 <span class="built_in">sleep</span> 1234</span><br></pre></td></tr></tbody></table></figure></li><li><p>将该挂起的进程转换成后台进程：<code>bg 1</code> or <code>bg</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bg</span> 1</span><br><span class="line">[1]+ <span class="built_in">sleep</span> 1234 &amp;</span><br><span class="line"><span class="comment"># jobs</span></span><br><span class="line">[1]+  Running                 <span class="built_in">sleep</span> 1234 &amp;</span><br></pre></td></tr></tbody></table></figure><ul><li>可以看到该进程状态从 <code>Stopped</code> 变为 <code>Running</code></li></ul></li><li><p>再将该后台进程转成前台进程: <code>fg</code> or <code>fg 1</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fg</span></span><br><span class="line"><span class="built_in">sleep</span> 1234</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>终端又被阻塞住了</li></ul></li><li><p>如何杀死一个后台进程？</p><ul><li>先用 <code>jobs</code> 查看后台进程的 jobid</li><li>然后使用 <code>kill %jobid</code> 关闭后台进程</li></ul></li><li><p>note:</p><ul><li><code>bg [%1]</code> <code>fg [%1]</code> 但是 <code>kill</code> 的jobid 不可省略: <code>kill %jobid</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> bash </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux：重定向</title>
      <link href="/2022/06/26/linux%EF%BC%9A%E9%87%8D%E5%AE%9A%E5%90%91/"/>
      <url>/2022/06/26/linux%EF%BC%9A%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="linux：-重定向"><a href="#linux：-重定向" class="headerlink" title="linux： 重定向"></a>linux： 重定向</h1><ul><li><p><code>&lt;</code>: 标准输入重定向</p></li><li><p><code>&gt; or 1&gt;</code>: 标准输出重定向</p></li><li><p><code>2&gt;</code>: 标准错误重定向</p></li><li><p><code>&amp;&gt;</code>: 混合输出重定向</p></li><li><p>准备 <code>redirect.sh</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello standard output"</span></span><br><span class="line"><span class="built_in">ls</span> -l xxx</span><br></pre></td></tr></tbody></table></figure><ul><li><p>先执行一次</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bash redirect.sh</span></span><br><span class="line">hello standard output</span><br><span class="line"><span class="built_in">ls</span>: cannot access xxx: No such file or directory</span><br></pre></td></tr></tbody></table></figure><ul><li>第一行是标准输出</li><li>第二行是错误输出</li></ul></li></ul></li></ul><h2 id="标准输出重定向"><a href="#标准输出重定向" class="headerlink" title="标准输出重定向"></a>标准输出重定向</h2><ul><li><code>cat &lt; redirect.sh</code></li></ul><h1 id="标准输出重定向-1"><a href="#标准输出重定向-1" class="headerlink" title="标准输出重定向"></a>标准输出重定向</h1><ul><li><p><code>bash redirect.sh &gt; output.txt</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bash redirect.sh &gt; output.txt</span></span><br><span class="line"><span class="built_in">ls</span>: cannot access xxx: No such file or directory</span><br></pre></td></tr></tbody></table></figure><ul><li>此时标准输出已经重定向到 <strong>output.txt</strong> 中，所以只输出错误输出</li></ul></li><li><p>追加输出重定向: <code>echo hello &gt;&gt; output.txt</code></p></li><li><p>输出重定向到 <code>/dev/null</code>: <code>bash redirect.sh &gt;/dev/null</code> 相当于丢弃程序的标准输出</p></li></ul><h2 id="标准错误重定向"><a href="#标准错误重定向" class="headerlink" title="标准错误重定向"></a>标准错误重定向</h2><ul><li><p><code>bash redirect.sh 2&gt; error.txt</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bash redirect.sh 2&gt; error.txt</span></span><br><span class="line">hello standard output</span><br></pre></td></tr></tbody></table></figure><ul><li>此时标准错误已经重定向到 <strong>error.txt</strong>中，所以只输出标准输出</li></ul></li><li><p>追加错误重定向: <code>bash redirect.sh 2&gt;&gt; error.txt</code></p></li><li><p>将标准错误重定向到标准输出: <code>ls xx  &gt;output.txt 2&gt;&amp;1</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls xx  &gt;output.txt 2&gt;&amp;1</span></span><br><span class="line"><span class="comment"># cat output.txt</span></span><br><span class="line"><span class="built_in">ls</span>: cannot access xx: No such file or directory</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="混合输出重定向"><a href="#混合输出重定向" class="headerlink" title="混合输出重定向"></a>混合输出重定向</h2><ul><li><p><code>bash redirect.sh &amp;&gt; mix.txt</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bash redirect.sh &amp;&gt; mix.txt</span></span><br><span class="line"><span class="comment"># cat mix.txt</span></span><br><span class="line">hello standard output</span><br><span class="line"><span class="built_in">ls</span>: cannot access xxx: No such file or directory</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2>]]></content>
      
      
      <categories>
          
          <category> bash </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux：login shell and no login shell</title>
      <link href="/2022/06/25/linux%EF%BC%9Alogin-shell-and-no-login-shell/"/>
      <url>/2022/06/25/linux%EF%BC%9Alogin-shell-and-no-login-shell/</url>
      
        <content type="html"><![CDATA[<h1 id="linux：login-shell-and-no-login-shell"><a href="#linux：login-shell-and-no-login-shell" class="headerlink" title="linux：login shell and no login shell"></a>linux：login shell and no login shell</h1><ul><li><p>先说结论，自己摸索下来（centos）的结果</p><ul><li><p><code>login shell(su - username)</code>:</p><ul><li><code>/etc/profile</code></li><li><code>~/.bash_profile</code></li><li>退出时执行 <code>~/.bash_logout</code></li></ul></li><li><p><code>no login shell(su name)</code>:</p><ul><li><code>~/.bashrc</code></li></ul></li></ul></li></ul><h2 id="login-shell"><a href="#login-shell" class="headerlink" title="login shell"></a>login shell</h2><ul><li><p>结论：依次执行 <code>/etc/profile</code> and <code>~/.bash_profile</code> 两个脚本文件，切换到用户的家目录</p></li><li><p>通过命令 <code>su - smx</code> 或者 ssh远程登陆 </p></li><li><p>会自动执行哪些 <code>shell</code>脚本</p><ol><li><p>首先执行的是 <code>/etc/profile</code> 脚本</p></li><li><p>其次执行的是 <code>~/.bash_profile</code> 脚本</p><ul><li><p>在 <code>~/.bash_profile</code> 脚本中又执行了 <code>~/.bashrc</code> 脚本</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .bash_profile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the aliases and functions</span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">. ~/.bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>在 <code>~/.bashrc</code>脚本中又执行了 <code>/etc/bashrc</code> 脚本</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/bashrc ]; <span class="keyword">then</span></span><br><span class="line">. /etc/bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol></li><li><p>如果在上面四个脚本的末尾都添加一句打印信息，那么登陆shell的执行结果应该是</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this is /etc/profile</span><br><span class="line">this is /etc/bashrc</span><br><span class="line">this is .bashrc for root user</span><br><span class="line">this is .bash_profile for root user</span><br></pre></td></tr></tbody></table></figure></li><li><p>退出时会执行 <code>~/.bash_logout</code> 脚本文件</p></li></ul><h2 id="no-login-shell"><a href="#no-login-shell" class="headerlink" title="no login shell"></a>no login shell</h2><ul><li>结论: 只执行 <code>~/.bashrc</code> 脚本文件，且去切换当前目录</li><li>通过命令 <code>su smx</code> 来切换用户</li><li>只会执行 <code>~/.bashrc</code> 脚本文件<ul><li><code>~/.bashrc</code> 内部 调用了 <code>/etc/bashrc</code></li></ul></li><li>退出时不会执行 <code>~/.bash_logout</code> 脚本文件</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>环境变量最好写在 <code>~/.bashrc</code> 文件中，因为不管 <code>login shell</code> 还是 <code>no login shell</code> 都会执行 <code>~/.bashrc</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux命令：which、locate、find命令的区别</title>
      <link href="/2022/06/25/linux%EF%BC%9Awhich%E3%80%81locate%E3%80%81find%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/06/25/linux%EF%BC%9Awhich%E3%80%81locate%E3%80%81find%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="linux命令：which、locate、find命令的区别"><a href="#linux命令：which、locate、find命令的区别" class="headerlink" title="linux命令：which、locate、find命令的区别"></a>linux命令：which、locate、find命令的区别</h1><h2 id="which"><a href="#which" class="headerlink" title="which"></a>which</h2><ul><li><p>用于查找环境变量 <strong>PATH</strong> 路径中具有可执行权限的文件</p></li><li><p>注意：</p><ul><li>PATH环境变量路径中查找</li><li>查找具有可执行权限的文件，并不一定是二进制文件，也有可能是文本文件</li></ul></li><li><p>samples</p><ul><li><p>在 <code>~/bin</code> 目录下 创建一个 <code>test.txt</code> 文本文件，并添加可执行权限，随后用which命令查看是否能找到</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos bin]<span class="comment"># which test.txt</span></span><br><span class="line">/usr/bin/which: no test.txt <span class="keyword">in</span> (/usr/local/bin/node16/bin:/usr/java/jdk1.8.0_121/bin:/opt/maven/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)</span><br><span class="line">[root@VM-16-5-centos bin]<span class="comment"># chmod + x test.txt</span></span><br><span class="line"><span class="built_in">chmod</span>: cannot access ‘x’: No such file or directory</span><br><span class="line">[root@VM-16-5-centos bin]<span class="comment"># chmod +x test.txt</span></span><br><span class="line">[root@VM-16-5-centos bin]<span class="comment"># which test.txt</span></span><br><span class="line">/root/bin/test.txt</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><ul><li><p>基于缓存文件数据库，快速查找文件或者目录。基于数据文件 <code>/var/lib/locatedb</code> 进行查找。</p></li><li><p>新添加的文件不会立即放到缓存数据库中，所以使用 locate 命令 找不到新添加的文件，这个时候你就需要使用　<strong>updatedb</strong> 来更新数据库。</p></li><li><p>samples</p><ul><li><p>新创建一个文本文件 <code>~/bin/test111.txt</code>， 并使用 locate 进行查找，发现并没有找到，随后执行 <code>updatedb</code> 命令，再用locate进行查找，会发现这个时候就能找到了</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos bin]<span class="comment"># touch test111.txt</span></span><br><span class="line">[root@VM-16-5-centos bin]<span class="comment"># updatedb</span></span><br><span class="line">[root@VM-16-5-centos bin]<span class="comment"># locate test111.txt</span></span><br><span class="line">/root/bin/test111.txt</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><ul><li><p>根据路径和条件自定义搜索文件</p></li><li><p>可以使用的参数很多，并且支持正则表达式，结合管道符后能够实现更加复杂的功能</p></li><li><p>格式: <code>find [路径] [参数]</code></p></li><li><p><strong>options</strong>:</p><table><thead><tr><th align="center">常用参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-name</td><td align="center">匹配名称</td></tr><tr><td align="center">-perm</td><td align="center">匹配权限（mode为完全匹配，-mode为包含即可）</td></tr><tr><td align="center">-user</td><td align="center">匹配所有者</td></tr><tr><td align="center">-group</td><td align="center">匹配所有组</td></tr><tr><td align="center">-mtime -n +n</td><td align="center">匹配修改内容的时间（-n指n天以内，+n指n天以前）</td></tr><tr><td align="center">-atime -n +n</td><td align="center">匹配访问文件的时间（-n指n天以内，+n指n天以前）</td></tr><tr><td align="center">-ctime -n +n</td><td align="center">匹配修改文件权限的时间（-n指n天以内，+n指n天以前）</td></tr><tr><td align="center">-nouser</td><td align="center">匹配无所有者的文件</td></tr><tr><td align="center">-nogroup</td><td align="center">匹配无所有组的文件</td></tr><tr><td align="center">-newer f1 !f2</td><td align="center">匹配比文件f1新但比f2旧的文件</td></tr><tr><td align="center">-type b/d/c/p/l/f</td><td align="center">匹配文件类型（后面的字幕字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件）</td></tr><tr><td align="center">-size</td><td align="center">匹配文件的大小（+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件）</td></tr><tr><td align="center">-prune</td><td align="center">忽略某个目录</td></tr><tr><td align="center">-exec …… {};</td><td align="center">后面可跟用于进一步处理搜索结果的命令</td></tr></tbody></table></li><li><p>samples</p><ul><li><p>全局搜索系统中那个所有以 <code>.conf</code> 结尾的文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name *.conf</span><br></pre></td></tr></tbody></table></figure></li><li><p>在<code>/etc</code>目录中搜索所有大于1M大小的文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /etc -size +1M</span><br></pre></td></tr></tbody></table></figure></li><li><p>在/home目录中搜索所有属于smx用户的文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -user smx</span><br></pre></td></tr></tbody></table></figure></li><li><p>在/var/log目录下搜索所有指定后缀为 <code>.log</code> 的文件，后缀不需要大小写。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /var/log -iname <span class="string">"*.log"</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>在/var/log目录下搜索所有后缀不是.log的文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /var/log ! -iname <span class="string">"*.log"</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>搜索当前工作目录中的所有近7天被修改过的文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -mtime -7</span><br></pre></td></tr></tbody></table></figure></li><li><p>全盘搜索系统中所有类型为普通文件，且可以执行的文件信息</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -<span class="built_in">type</span> f -perm /a=x</span><br></pre></td></tr></tbody></table></figure></li><li><p>全盘搜索系统中所有类型为目录，且权限为1777的目录文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -<span class="built_in">type</span> d -perm 1777</span><br></pre></td></tr></tbody></table></figure></li><li><p>全盘搜索系统中所有后缀为.mp4的文件，并删除所有查找到的文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name <span class="string">"*.mp4"</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> -rf {} \;</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> commands </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux：shell脚本练习</title>
      <link href="/2022/06/24/linux%EF%BC%9Ashell%E8%84%9A%E6%9C%AC%E7%BB%83%E4%B9%A0/"/>
      <url>/2022/06/24/linux%EF%BC%9Ashell%E8%84%9A%E6%9C%AC%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="linux：shell脚本练习"><a href="#linux：shell脚本练习" class="headerlink" title="linux：shell脚本练习"></a>linux：shell脚本练习</h1><h2 id="demo-txt-files"><a href="#demo-txt-files" class="headerlink" title="demo txt files"></a>demo txt files</h2><ul><li><p><code>demo1.txt</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">my</span><br><span class="line">name  is</span><br><span class="line">smx  </span><br><span class="line"></span><br><span class="line">and </span><br><span class="line">what </span><br><span class="line"></span><br><span class="line">is </span><br><span class="line"></span><br><span class="line">your </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name?</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="practices"><a href="#practices" class="headerlink" title="practices"></a>practices</h2><ul><li><p>一行一行地读取 <code>demo1.txt</code> 并输出: <code>reaf_file_line_by_line.sh</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="comment"># 一行一行读取 demo1.txt 并输出</span></span><br><span class="line"><span class="keyword">while</span> IFS= <span class="built_in">read</span> -r  line </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span> &lt; demo1.txt</span><br></pre></td></tr></tbody></table></figure></li><li><p>将文本文件<code>demo1.txt</code>的所有内容读取到变量中并打印出来: <code>read_file_to_variable.sh</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="comment"># 将文本文件demo1.txt的所有内容读取到变量中并打印出来</span></span><br><span class="line">text=`<span class="built_in">cat</span> demo1.txt`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$text</span> <span class="comment"># my name is smx and what is your name?</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$text</span>"</span> <span class="comment"># 正常打印，带有换行符</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>将文本文件 <code>demo1.txt</code> 内容以空白字符分隔成一个数组: <code>split_file_to_array.sh</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="comment"># 将文本文件 `demo1.txt` 内容以空白字符分隔成一个数组</span></span><br><span class="line">text=$(<span class="built_in">cat</span> demo1.txt)</span><br><span class="line">a=(<span class="variable">$text</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"数组a的长度为:<span class="variable">${#a[*]}</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"数组为: "</span> <span class="variable">$text</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>判断字符串是否包含另外一个字符串: <code>str_contain_str.sh</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="comment"># 判断字符串是否包含另外一个字符串</span></span><br><span class="line">str=<span class="string">"my name is smx"</span></span><br><span class="line">substr=smx</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"*<span class="variable">${substr}</span>*"</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$str</span>"</span> == *<span class="variable">${substr}</span>* ]]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"cotain substr: <span class="variable">$substr</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"do not contain substr: <span class="variable">$substr</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>在这里做了测试</p><ul><li><code>[[ "$str" == *"${substr}"* ]]</code>  可以，√</li><li><code>[[ *${substr}* == "$str" ]]</code> 不可以，× </li><li><code>[[ "$str" == "*${substr}*" ]]</code> 不可以，× </li><li><code>[ "$str" == *"${substr}"* ]</code>  不可以，×</li></ul></li><li><p>还有一种写法，不明白什么含义：<code>str_contain_str2.sh</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="comment"># 判断字符串是否包含另外一个字符串</span></span><br><span class="line">str=<span class="string">"my name is smx"</span></span><br><span class="line">substr=smx</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"*<span class="variable">${substr}</span>*"</span></span><br><span class="line"><span class="keyword">if</span> grep -q <span class="string">"<span class="variable">$substr</span>"</span> &lt;&lt;&lt; <span class="variable">$str</span>;  <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"cotain substr: <span class="variable">$substr</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"do not contain substr: <span class="variable">$substr</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure><ul><li>grep 如果找到 返回0 如果没找到返回1 -q quietly 即使找到也不输出到标准输出</li></ul></li></ul></li><li><p>判断文本文件 <code>demo1.txt</code> 是否包含字符串 <code>name</code> or <code>xxx</code>: <code>file_contain_str.sh</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="comment"># 判断文本文件 `demo1.txt` 是否包含字符串 `name` or `xxx`</span></span><br><span class="line"></span><br><span class="line">file=demo1.txt</span><br><span class="line">str=name</span><br><span class="line"><span class="keyword">if</span> [[ `<span class="built_in">cat</span> <span class="variable">$file</span>` == *<span class="string">"<span class="variable">$str</span>"</span>* ]]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"file named of <span class="variable">$file</span> contain str: <span class="variable">$str</span>"</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"file named of <span class="variable">$file</span> does not contain str: <span class="variable">$str</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">str=xxx</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ $(<span class="built_in">cat</span> <span class="variable">$file</span>) == *<span class="string">"<span class="variable">$str</span>"</span>* ]]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"file named of <span class="variable">$file</span> contain str: <span class="variable">$str</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"file named of <span class="variable">$file</span> does not contain str: <span class="variable">$str</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux：shell脚本执行方式</title>
      <link href="/2022/06/24/linux%EF%BC%9Ashell%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/06/24/linux%EF%BC%9Ashell%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux：shell脚本执行方式"><a href="#Linux：shell脚本执行方式" class="headerlink" title="Linux：shell脚本执行方式"></a>Linux：shell脚本执行方式</h1><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><ul><li><a href="https://github.com/baby-Jie/blog_codes/blob/main/shell/execute_shell/execute.sh">execute.sh</a></li></ul><h2 id="shell脚本第一行-usr-bin-bash-详解"><a href="#shell脚本第一行-usr-bin-bash-详解" class="headerlink" title="shell脚本第一行 #!/usr/bin/bash 详解"></a>shell脚本第一行 <code>#!/usr/bin/bash</code> 详解</h2><ul><li><p>shell脚本的第一行 <code>#!/usr/bin/bash</code> 不是注释，而是告诉解释器使用一种什么样的方式去执行该脚本</p></li><li><p>当我们使用绝对路径或者相对路径去执行该脚本的时候，就会用第一行指定的解释器去执行</p></li><li><p><code>#!</code> 读作 <code>SheBang</code> 必须放在第一行才起作用</p></li><li><p>不仅仅是 shell 脚本，python脚本等也是需要添加 <code>#!</code></p></li><li><p><code>test.py</code></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="built_in">print</span> hello python</span><br></pre></td></tr></tbody></table></figure><ul><li>执行 <code>./test.py</code></li></ul></li></ul><h2 id="shell脚本有几种执行方式"><a href="#shell脚本有几种执行方式" class="headerlink" title="shell脚本有几种执行方式"></a>shell脚本有几种执行方式</h2><ul><li>在日常使用中，一般有五种方式去执行 shell 脚本<ol><li><code>bash test.sh</code></li><li><code>./test.sh</code></li><li><code>sh test.sh</code></li><li><code>source test.sh</code></li><li><code>. test.sh</code></li></ol></li><li>其实上面的五种执行方式可以缩减为三种，其中在大多数linux版本中 <code>sh</code> 是链接到  <code>bash</code> 上的，而 <code>source xx.sh</code> 和 <code>. xx.sh</code> 一致，那我们可以将执行方式分成三种:<ol><li><code>bash test.sh</code></li><li><code>./test.sh</code></li><li><code>source test.sh</code></li></ol></li></ul><h2 id="三种执行方式的区别"><a href="#三种执行方式的区别" class="headerlink" title="三种执行方式的区别"></a>三种执行方式的区别</h2><h3 id="bash-test-sh"><a href="#bash-test-sh" class="headerlink" title="bash test.sh"></a>bash test.sh</h3><ul><li>在子shell中执行</li><li>不需要文件具有执行权限</li></ul><h3 id="x2F-test-sh"><a href="#x2F-test-sh" class="headerlink" title="./test.sh"></a>./test.sh</h3><ul><li>这是以相对路径来执行的，也可以使用绝对路径来执行: <code>/home/smx/test.sh</code></li><li>在子shell中执行</li><li>需要文件具有执行权限</li></ul><h3 id="source-test-sh-or-test-sh"><a href="#source-test-sh-or-test-sh" class="headerlink" title="source test.sh or . test.sh"></a>source test.sh or . test.sh</h3><ul><li>在当前shell中执行</li><li>不需要文件具有执行权限</li></ul><h2 id="在当前shell中执行与在子shell中执行究竟有什么区别呢"><a href="#在当前shell中执行与在子shell中执行究竟有什么区别呢" class="headerlink" title="在当前shell中执行与在子shell中执行究竟有什么区别呢"></a>在当前shell中执行与在子shell中执行究竟有什么区别呢</h2><ul><li>先说结论：在当前shell中执行会影响到当前shell的上下文，在子shell中执行不会影响到当前的shell</li></ul><h3 id="sample-execute-sh"><a href="#sample-execute-sh" class="headerlink" title="sample: execute.sh"></a>sample: execute.sh</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> start...</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">cd</span> /home</span><br><span class="line"><span class="built_in">echo</span> end...</span><br></pre></td></tr></tbody></table></figure><ul><li><p>首先在当前shell中设置变量 <code>a=111</code>, 然后使用 <code>bash execute.sh</code> 查看执行结果</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos execute_shell]<span class="comment"># a=111</span></span><br><span class="line">[root@VM-16-5-centos execute_shell]<span class="comment"># bash execute.sh</span></span><br><span class="line">start...</span><br><span class="line"></span><br><span class="line">end...</span><br><span class="line">[root@VM-16-5-centos execute_shell]<span class="comment"># </span></span><br></pre></td></tr></tbody></table></figure></li><li><p>这里主要查看两个地方</p><ol><li>查看变量a是否有值：没有</li><li>当前shell是否切换到了 <code>/home</code> 目录下：没有</li></ol></li><li><p>再使用 <code>source execute.sh</code> 执行并查看执行结果</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos execute_shell]<span class="comment"># source execute.sh</span></span><br><span class="line">start...</span><br><span class="line">111</span><br><span class="line">end...</span><br><span class="line">[root@VM-16-5-centos home]<span class="comment"># </span></span><br></pre></td></tr></tbody></table></figure></li><li><p>可以看到：既打印了当前shell中a变量的值，又切换了当前shell的路径</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux：bash遇到错误自动停止，不再继续执行</title>
      <link href="/2022/06/23/linux%EF%BC%9Abash%E9%81%87%E5%88%B0%E9%94%99%E8%AF%AF%E8%87%AA%E5%8A%A8%E5%81%9C%E6%AD%A2%EF%BC%8C%E4%B8%8D%E5%86%8D%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C/"/>
      <url>/2022/06/23/linux%EF%BC%9Abash%E9%81%87%E5%88%B0%E9%94%99%E8%AF%AF%E8%87%AA%E5%8A%A8%E5%81%9C%E6%AD%A2%EF%BC%8C%E4%B8%8D%E5%86%8D%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="linux：bash遇到错误自动停止，不再继续执行"><a href="#linux：bash遇到错误自动停止，不再继续执行" class="headerlink" title="linux：bash遇到错误自动停止，不再继续执行"></a>linux：bash遇到错误自动停止，不再继续执行</h1><ul><li><p>首先看一段shell脚本</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> start</span><br><span class="line"><span class="built_in">rm</span> <span class="built_in">test</span> <span class="comment"># test is not exist</span></span><br><span class="line"><span class="built_in">echo</span> end</span><br></pre></td></tr></tbody></table></figure></li><li><p>执行脚本</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos files]<span class="comment"># bash test3.sh</span></span><br><span class="line">start</span><br><span class="line"><span class="built_in">rm</span>: cannot remove ‘<span class="built_in">test</span>’: No such file or directory</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure></li><li><p>可以看到 虽然 <code>rm test</code> 执行失败了，但是 第三条命令依然执行了</p></li><li><p>这个结果不是我想要的，我想要bash在执行的过程中遇到错误就自动停止执行 有两种解决方案</p><ol><li><p>手动判断并退出</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> start</span><br><span class="line"><span class="built_in">rm</span> <span class="built_in">test</span> <span class="comment"># test is not exist</span></span><br><span class="line"><span class="keyword">if</span> (($? != 0)); <span class="keyword">then</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> end</span><br></pre></td></tr></tbody></table></figure><ul><li><p>执行结果:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos files]<span class="comment"># bash test3.sh</span></span><br><span class="line">start</span><br><span class="line"><span class="built_in">rm</span>: cannot remove ‘<span class="built_in">test</span>’: No such file or directory</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>使用 <code>-e</code> 参数去执行脚本: <strong>bash -e test3.sh</strong></p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> bash </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC：Post请求乱码问题解决</title>
      <link href="/2022/06/22/SpringMVC%EF%BC%9APost%E8%AF%B7%E6%B1%82%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2022/06/22/SpringMVC%EF%BC%9APost%E8%AF%B7%E6%B1%82%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC：Post请求乱码问题解决"><a href="#SpringMVC：Post请求乱码问题解决" class="headerlink" title="SpringMVC：Post请求乱码问题解决"></a>SpringMVC：Post请求乱码问题解决</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>post请求发送中文字符时，在服务端接收到后打印会出现乱码</li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="使用SpringMVC自带的-CharacterEncodingFilter"><a href="#使用SpringMVC自带的-CharacterEncodingFilter" class="headerlink" title="使用SpringMVC自带的 CharacterEncodingFilter"></a>使用SpringMVC自带的 CharacterEncodingFilter</h3><ul><li><p>在 <code>web.xml</code> 中添加 <code>CharacterEncodingFilter</code> 即可</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="自己手写个-Filter-CharacterEncodingFilter"><a href="#自己手写个-Filter-CharacterEncodingFilter" class="headerlink" title="自己手写个 Filter: CharacterEncodingFilter"></a>自己手写个 Filter: CharacterEncodingFilter</h3><ul><li><p>在 <code>web.xml</code> 中添加 <code>CharacterEncodingFilter</code></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.smx.mvc.filters.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><code>CharacterEncodingFilter</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> smx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-06-22 10:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharacterEncodingFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException {}</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException {</span><br><span class="line">        <span class="keyword">if</span> (servletRequest <span class="keyword">instanceof</span> HttpServletRequest) {</span><br><span class="line">            <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"POST"</span>.equalsIgnoreCase(request.getMethod())) {</span><br><span class="line">                request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 这里一定不要忘了放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> {}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> SpringMVC </tag>
            
            <tag> filter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux文本命令: awk</title>
      <link href="/2022/06/22/linux%E6%96%87%E6%9C%AC%E5%91%BD%E4%BB%A4%EF%BC%9Aawk/"/>
      <url>/2022/06/22/linux%E6%96%87%E6%9C%AC%E5%91%BD%E4%BB%A4%EF%BC%9Aawk/</url>
      
        <content type="html"><![CDATA[<h1 id="linux文本命令-awk"><a href="#linux文本命令-awk" class="headerlink" title="linux文本命令 awk"></a>linux文本命令 awk</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li><strong>sed</strong> 命令是基于<strong>行</strong>为单位的文本处理工具，而 <strong>awk</strong> 则是基于列的文本处理工具。</li><li>awk命令将每行（每条记录）分割成若干个字段(field)，默认以空白字符分割，然后输出各个字段的值</li><li>字段参数:<ul><li><code>$0</code>: 所有的字段，就是一行</li><li><code>$1</code>: 第一个字段</li><li><code>$2</code>: 第二个字段</li><li><code>NF</code>: 字段数量</li><li><code>$NF</code>: 最后一个字段</li><li><code>$(NF-1):</code> 倒数第二个字段</li></ul></li></ul><h3 id="awk-和-gawk"><a href="#awk-和-gawk" class="headerlink" title="awk 和 gawk"></a>awk 和 gawk</h3><ul><li><p>awk语言最初在unix下作为awk实用程序实现的。大多数linux发布版本都提供<strong>gawk</strong>(awk的GNU实现)或者 <strong>mawk</strong>(awk的一个快速、删减版本)。<code>gawk</code> 基本上能够兼容 <code>awk</code></p></li><li><p>一般linux版本，会将 <code>awk</code> 链接到 <code>gawk</code>，所以本文所说的 <code>awk</code> 就是 <code>gawk</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx. 1 root root 4 Mar  7  2019 /usr/bin/awk -&gt; gawk</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li><code>awk [options] [program] [file-list]</code></li><li><code>awk [options] -f program-file [file-list]</code></li></ul><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><table><thead><tr><th>short options</th><th>long options</th><th>meanings</th></tr></thead><tbody><tr><td>-F fs</td><td>–field-seperators</td><td>将fs作为输入字段分隔符(FS变量)的值</td></tr><tr><td>-f program-file</td><td>–file program-file</td><td>从文件中读取awk程序</td></tr><tr><td>-W help</td><td>–help</td><td>帮助</td></tr><tr><td>-v var=value</td><td>–assign var=value</td><td>把value赋予变量var。在awk程序执行之前进行赋值，它可用于BEGIN模式中。可在命令行上多次指定这个选项</td></tr></tbody></table><h2 id="Samples"><a href="#Samples" class="headerlink" title="Samples"></a>Samples</h2><ul><li><p>准备文本 <code>awk.txt</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">john.wangMale30021-11111111</span><br><span class="line">lucy.yangFemale25021-22222222</span><br><span class="line">jack.chenMale35021-33333333</span><br><span class="line">lily.gongFemale20021-44444444ShangHai</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="打印指定区字段"><a href="#打印指定区字段" class="headerlink" title="打印指定区字段"></a>打印指定区字段</h3><ul><li>打印 <code>awk.txt</code> 中的姓名和电话: <code>awk {print $1, $4}</code> awk.txt</li></ul><h3 id="指定分隔符分割字段"><a href="#指定分隔符分割字段" class="headerlink" title="指定分隔符分割字段"></a>指定分隔符分割字段</h3><ul><li>使用 <code>-F</code> 选项</li><li>打印 <code>/etc/passwd</code> 中的用户名和用户默认使用的shell: <ul><li><code>awk -F: '{print $1, $7}' /etc/passwd</code></li></ul></li></ul><h3 id="格式化打印"><a href="#格式化打印" class="headerlink" title="格式化打印"></a>格式化打印</h3><ul><li>打印 <code>/etc/passwd</code> 中的用户和默认shell，使用连字符<code>-</code> 相连<ul><li><code>awk -F: '{printf "%s-%s\n", $1, $7}' /etc/passwd</code></li></ul></li></ul><h3 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h3><h3 id="NF-字段数"><a href="#NF-字段数" class="headerlink" title="NF 字段数"></a>NF 字段数</h3><ul><li>分别打印 <code>awk.txt</code> 中每行的字段数<ul><li><code>awk '{print NF}' awk.txt</code></li></ul></li><li>打印倒数<code>awk.txt</code>中的倒数第二个字段：<ul><li><code>aek '{print $(NF-1)}' awk.txt</code></li></ul></li></ul><h4 id="NR-行数、记录数"><a href="#NR-行数、记录数" class="headerlink" title="NR 行数、记录数"></a>NR 行数、记录数</h4><ul><li>打印NR(Number of Record):<ul><li><code>awk '{print NR}' awk.txt</code></li></ul></li></ul><h4 id="FS-字段分隔符"><a href="#FS-字段分隔符" class="headerlink" title="FS 字段分隔符"></a>FS 字段分隔符</h4><h3 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h3><ul><li>可以使用 <code>substr()</code> 函数对指定字段截取字符串：<code>substr(指定域，startPos, endPos)</code></li><li>将<code>awk.txt</code>中的第一个字段中的姓截取出来:<ul><li><code>awk '{print substr($1, 6)}' awk.txt</code></li></ul></li></ul><h3 id="获取行的长度"><a href="#获取行的长度" class="headerlink" title="获取行的长度"></a>获取行的长度</h3><ul><li>获取 <code>awk.txt</code> 每行的长度<ul><li><code>awk '{print length}' awk.txt</code></li></ul></li></ul><h3 id="使用awk求和、求-平均值"><a href="#使用awk求和、求-平均值" class="headerlink" title="使用awk求和、求 平均值"></a>使用awk求和、求 平均值</h3><ul><li>求 <code>awk.txt</code> 中年龄的和<ul><li><code>awk 'BEGIN{total=0}{total+=$3}END{print total}' awk.txt</code></li></ul></li><li>求 <code>awk.txt</code> 中年龄的平均值<ul><li><code>awk 'BEGIN{total=0}{total+=$3}END{print total/NR} awk.txt'</code></li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><code>&lt;&lt;Linux系统命令及Shell脚本实践指南&gt;&gt;</code></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> commands </tag>
            
            <tag> linux </tag>
            
            <tag> text commands </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习计划</title>
      <link href="/2022/06/20/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
      <url>/2022/06/20/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h1><h2 id="2022年6月20日-2022年6月26日"><a href="#2022年6月20日-2022年6月26日" class="headerlink" title="2022年6月20日 - 2022年6月26日"></a>2022年6月20日 - 2022年6月26日</h2><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><ul><li>linux复习</li><li>linux深入学习</li></ul><h3 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h3>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux文本命令：cut</title>
      <link href="/2022/06/19/linux%E6%96%87%E6%9C%AC%E5%91%BD%E4%BB%A4%EF%BC%9Acut/"/>
      <url>/2022/06/19/linux%E6%96%87%E6%9C%AC%E5%91%BD%E4%BB%A4%EF%BC%9Acut/</url>
      
        <content type="html"><![CDATA[<h1 id="linux文本命令：sort"><a href="#linux文本命令：sort" class="headerlink" title="linux文本命令：sort"></a>linux文本命令：sort</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><p><code>cut</code> - remove sections from each line of files </p><ul><li>切片与切块，从每行中删除部分内容</li><li>cut可用于从每行提取部分文本并将其输出至标准输出。它能够接受多个文件参数或从标准输入中获取输入。</li></ul></li><li><p>语法: <strong>cut OPTION… [FILE]…</strong></p></li><li><p><strong>options</strong>:</p><table><thead><tr><th align="center">选项</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-c list, –characters=list</td><td align="center">提取由list定义的部分行。list可以是一个或者多个逗号分隔的数值范围</td></tr><tr><td align="center">-f list, –fields=list</td><td align="center">从行中提取由list定义的一个或者多个字段。list可以包含一个或多个字段，抑或是逗号分隔的字段范围</td></tr><tr><td align="center">-d delim, –delimiter=delim</td><td align="center">如果指定了-f，则使用 delim作为字段分隔符。在默认情况下，字段必须由单个制表符分隔</td></tr></tbody></table></li></ul><h2 id="samples"><a href="#samples" class="headerlink" title="samples"></a>samples</h2><h3 id="牛刀小试"><a href="#牛刀小试" class="headerlink" title="牛刀小试"></a>牛刀小试</h3><ul><li><p>我们也看到了，cut提取文本的方式“相当死板”。cut适合从其他程序产生的文件中提取文本，而不是从用户的输入中直接提取。来看一看我们的distros.txt文件是否“干净”到足以作为cat示例的良好样本。将cat与-A选项一起使用，就能看出该文件是否符合以制表符作为字段分隔符的要求：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos <span class="built_in">cut</span>]<span class="comment"># cat -A distros.txt </span></span><br><span class="line">SUSE^I10.2^I12/07/2006$</span><br><span class="line">Fedora^I10^I11/25/2008$</span><br><span class="line">SUSE^I11.0^I06/19/2008$</span><br><span class="line">Ubuntu^I8.04^I04/24/2008$</span><br><span class="line">Fedora^I8^I11/08/2007$</span><br><span class="line">SUSE^I10.3^I10/04/2007$</span><br><span class="line">Ubuntu^I6.10^I10/26/2006$</span><br><span class="line">Fedora^I7^I05/31/2007$</span><br><span class="line">Ubuntu^I7.10^I10/18/2007$</span><br><span class="line">Ubuntu^I7.04^I04/19/2007$</span><br><span class="line">SUSE^I10.1^I05/11/2006$</span><br><span class="line">Fedora^I6^I10/24/2006$</span><br><span class="line">Fedora^I9^I05/13/2008$</span><br><span class="line">Ubuntu^I6.06^I06/01/2006$</span><br><span class="line">Ubuntu^I8.10^I10/30/2008$</span><br><span class="line">Fedora^I5^I03/20/2006$</span><br></pre></td></tr></tbody></table></figure></li><li><p>看起来是没有内嵌空格，全部以 <code>\t</code> 来分隔，那我们接下来把日期提取出来:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos <span class="built_in">cut</span>]<span class="comment"># cut -f 3 distros.txt </span></span><br><span class="line">12/07/2006</span><br><span class="line">11/25/2008</span><br><span class="line">06/19/2008</span><br><span class="line">04/24/2008</span><br><span class="line">11/08/2007</span><br><span class="line">10/04/2007</span><br><span class="line">10/26/2006</span><br><span class="line">05/31/2007</span><br><span class="line">10/18/2007</span><br><span class="line">04/19/2007</span><br><span class="line">05/11/2006</span><br><span class="line">10/24/2006</span><br><span class="line">05/13/2008</span><br><span class="line">06/01/2006</span><br><span class="line">10/30/2008</span><br><span class="line">03/20/2006</span><br></pre></td></tr></tbody></table></figure></li><li><p>如果我们只想要把日期中的年份提取出来呢？那么我们需要在前面的基础上，提取字符区间</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos <span class="built_in">cut</span>]<span class="comment"># cut -f3 distros.txt | cut -c7-10</span></span><br><span class="line">2006</span><br><span class="line">2008</span><br><span class="line">2008</span><br><span class="line">2008</span><br><span class="line">2007</span><br><span class="line">2007</span><br><span class="line">2006</span><br><span class="line">2007</span><br><span class="line">2007</span><br><span class="line">2007</span><br><span class="line">2006</span><br><span class="line">2006</span><br><span class="line">2008</span><br><span class="line">2006</span><br><span class="line">2008</span><br><span class="line">2006</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="查看当前系统中，所有的用户名称-etc-passwd"><a href="#查看当前系统中，所有的用户名称-etc-passwd" class="headerlink" title="查看当前系统中，所有的用户名称 /etc/passwd"></a>查看当前系统中，所有的用户名称 <code>/etc/passwd</code></h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos <span class="built_in">cut</span>]<span class="comment"># cut -d ":" -f1 /etc/passwd | head</span></span><br><span class="line">root</span><br><span class="line">bin</span><br><span class="line">daemon</span><br><span class="line">adm</span><br><span class="line">lp</span><br><span class="line"><span class="built_in">sync</span></span><br><span class="line">shutdown</span><br><span class="line">halt</span><br><span class="line">mail</span><br><span class="line">operator</span><br></pre></td></tr></tbody></table></figure><h2 id="扩展制表符"><a href="#扩展制表符" class="headerlink" title="扩展制表符"></a>扩展制表符</h2><ul><li><p>distros.txt文件采用了适合于cut提取字段的理想格式。但如果我们希望文件完全能由cut按照字符（而非字段）操作，该怎么办？这需要使用相应数量的空格符替换掉文件中的制表符。幸运的是，GNU Coreutils软件包中就有这么一件工具：expand。该命令接受一个或多个文件参数，也可以接受标准输入，修改后的文本被输出至标准输出。</p></li><li><p>如果事先通过expand处理过distros.txt文件，就能直接使用cut -c从文件中提取任意范围的字符。例如，我们可以先使用expand扩展该文件，再使用cut提取每行第23个字符到行尾的所有内容，这样就得到了发行年份：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">expand</span> distros.txt | <span class="built_in">cut</span> -c 23</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> commands </tag>
            
            <tag> linux </tag>
            
            <tag> text commands </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux文本命令：uniq</title>
      <link href="/2022/06/19/linux%E6%96%87%E6%9C%AC%E5%91%BD%E4%BB%A4%EF%BC%9Auniq/"/>
      <url>/2022/06/19/linux%E6%96%87%E6%9C%AC%E5%91%BD%E4%BB%A4%EF%BC%9Auniq/</url>
      
        <content type="html"><![CDATA[<h1 id="linux文本命令：uniq"><a href="#linux文本命令：uniq" class="headerlink" title="linux文本命令：uniq"></a>linux文本命令：uniq</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><p><code>uniq</code> - report or omit repeated lines</p></li><li><p>uniq 只能删除那些连续重复的行，所以一般都配合 sort 命令使用</p></li><li><p>语法: <code>uniq [OPTION]... [INPUT [OUTPUT]]</code></p></li><li><p><strong>options</strong></p><table><thead><tr><th align="center">选项</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-c, –count</td><td align="center">输出重复行，在其之前加上该行重复出现的次数</td></tr><tr><td align="center">-d, –repeated</td><td align="center">只输出重复行，不包括非重复行</td></tr><tr><td align="center">-f n, –skip-fields=n</td><td align="center">忽略每行前n个字段，和sort一样，字段以空白字符分隔；但不同于sort，uniq没有能够设置其他字段分隔符的选项</td></tr><tr><td align="center">-i, –ignore-case</td><td align="center">忽略大小写</td></tr><tr><td align="center">-s n, –skip-chars=n</td><td align="center">跳过每行开始的前n个字符</td></tr><tr><td align="center">-u, –unique</td><td align="center">只输出不重复的行，忽略重复行</td></tr></tbody></table></li></ul><h2 id="samples"><a href="#samples" class="headerlink" title="samples"></a>samples</h2><h3 id="牛刀小试"><a href="#牛刀小试" class="headerlink" title="牛刀小试"></a>牛刀小试</h3><ul><li><p>准备 <code>uniq.txt</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></tbody></table></figure></li><li><p>首先要排序然后再 <code>uniq</code>: <code>sort uniq.txt | uniq</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos <span class="built_in">uniq</span>]<span class="comment"># sort uniq.txt | uniq</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></tbody></table></figure></li><li><p>查看重复行的行数: <code>sort uniq.txt | uniq -c</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos <span class="built_in">uniq</span>]<span class="comment"># sort uniq.txt | uniq -c</span></span><br><span class="line">      2 a</span><br><span class="line">      2 b</span><br><span class="line">      2 c</span><br></pre></td></tr></tbody></table></figure></li><li><p>注意: <code>-c</code> 选项只能查看重复的行，不重复的行是不显示的</p><ul><li><code>uniq2.txt</code></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></tbody></table></figure><ul><li><p><code>sort uniq2.txt | uniq -c</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos <span class="built_in">uniq</span>]<span class="comment"># sort uniq.txt | uniq -c</span></span><br><span class="line">      2 a</span><br><span class="line">      2 b</span><br><span class="line">      2 c</span><br></pre></td></tr></tbody></table></figure><ul><li>从以上结果看出，并没有显示 <code>d</code> 行</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> commands </tag>
            
            <tag> linux </tag>
            
            <tag> text commands </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux文本命令：sort</title>
      <link href="/2022/06/19/linux%E6%96%87%E6%9C%AC%E5%91%BD%E4%BB%A4%EF%BC%9Asort/"/>
      <url>/2022/06/19/linux%E6%96%87%E6%9C%AC%E5%91%BD%E4%BB%A4%EF%BC%9Asort/</url>
      
        <content type="html"><![CDATA[<h1 id="linux文本命令：sort"><a href="#linux文本命令：sort" class="headerlink" title="linux文本命令：sort"></a>linux文本命令：sort</h1><h2 id="sort命令简介"><a href="#sort命令简介" class="headerlink" title="sort命令简介"></a>sort命令简介</h2><ul><li><p><code>sort</code> - <code>sort lines of text files</code> 对文本行进行排序</p></li><li><p>sort可以排序多个文件并合并成单个有序文件: <code>sort file1 file2 file3 &gt; output</code></p></li><li><p>语法：<code>sort [option]... [file]...</code></p></li><li><p><strong>options</strong>:</p><table><thead><tr><th align="center">选项</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>-b, --ignore-leading-blanks</code></td><td align="center">在默认情况下，对整行进行排序，从行内的的第一个字符开始。该选项使sort忽略每行开头的空白字符，从第一个非空白字符串开始排序</td></tr><tr><td align="center"><code>-f, --ignore-case</code></td><td align="center">排序时不区分大小写</td></tr><tr><td align="center"><code>-n,--numeric-sort</code></td><td align="center">根据字符串的数值排序，而不是按照字典顺序。</td></tr><tr><td align="center"><code>-r, --reverse</code></td><td align="center">降序排序</td></tr><tr><td align="center"><code>-k, --key=field1[,field2]</code></td><td align="center">不再按照整行排序，按照字段区间范围排序</td></tr><tr><td align="center"><code>-m, --merge</code></td><td align="center">每个参数视为已经排序过的文件，只合并，不再执行额外的排序</td></tr><tr><td align="center"><code>-o, --output=file</code></td><td align="center">将output写到目标文件中，而不是标准输出</td></tr><tr><td align="center"><code>-t, --field-separator=char</code></td><td align="center">定义字段分隔符。在默认情况下，字段由<strong>空白符</strong>(空格符或制表符)分隔</td></tr></tbody></table></li></ul><h2 id="samples"><a href="#samples" class="headerlink" title="samples"></a>samples</h2><h3 id="牛刀小试"><a href="#牛刀小试" class="headerlink" title="牛刀小试"></a>牛刀小试</h3><ul><li><p>创建一个文本文件 <code>sort.txt</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">b</span><br><span class="line">a</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用 <code>sort</code> 进行排序（并不会改变源文件）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sort</span> sort.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="查看-usr-share-目录下-所有文件磁盘占用情况并进行排序"><a href="#查看-usr-share-目录下-所有文件磁盘占用情况并进行排序" class="headerlink" title="查看  /usr/share/ 目录下 所有文件磁盘占用情况并进行排序"></a>查看  <code>/usr/share/</code> 目录下 所有文件磁盘占用情况并进行排序</h3><ul><li><p>查看 <code>/usr/share/</code> 目录磁盘占用情况, <code>du -s /usr/share/* | head</code>， 这里由于文件太多就截取了前10个</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">44/usr/share/abrt</span><br><span class="line">684/usr/share/aclocal</span><br><span class="line">160/usr/share/aclocal-1.13</span><br><span class="line">1332/usr/share/alsa</span><br><span class="line">648/usr/share/anaconda</span><br><span class="line">36/usr/share/applications</span><br><span class="line">1100/usr/share/augeas</span><br><span class="line">440/usr/share/authconfig</span><br><span class="line">1700/usr/share/autoconf</span><br><span class="line">1092/usr/share/automake-1.13</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用sort进行排序: <code>du -s /usr/share/* | sort | head</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos ~]# du -s /usr/share/* | sort | head</span><br><span class="line">0/usr/share/gcc-4.8.5</span><br><span class="line">0/usr/share/magic</span><br><span class="line">0/usr/share/redhat-release</span><br><span class="line">100588/usr/share/doc</span><br><span class="line">1092/usr/share/automake-1.13</span><br><span class="line">1100/usr/share/augeas</span><br><span class="line">114608/usr/share/locale</span><br><span class="line">116/usr/share/gcc-4.8.2</span><br><span class="line">120/usr/share/zsh</span><br><span class="line">12/usr/share/glvnd</span><br></pre></td></tr></tbody></table></figure></li><li><p>从以上结果可以发现，该排序结果使按照字典序进行排序的，不是我们想要的结果，我们可以添加 <code>-n</code> 选项指定按照数字排序: <code>du -s /usr/share/* | sort -n | head</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos ~]# du -s /usr/share/* | sort -n | head</span><br><span class="line">0/usr/share/gcc-4.8.5</span><br><span class="line">0/usr/share/magic</span><br><span class="line">0/usr/share/redhat-release</span><br><span class="line">4/usr/share/desktop-directories</span><br><span class="line">4/usr/share/dict</span><br><span class="line">4/usr/share/empty</span><br><span class="line">4/usr/share/file</span><br><span class="line">4/usr/share/firewalld</span><br><span class="line">4/usr/share/games</span><br><span class="line">4/usr/share/gnome</span><br></pre></td></tr></tbody></table></figure></li><li><p>呃，以上是升序排序，我们要的是占用磁盘最多的文件，应该使用<code>-r</code> 来降序排序: <code>du -s /usr/share/* | sort -nr | head</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos ~]# du -s /usr/share/* | sort -nr | head</span><br><span class="line">114608/usr/share/locale</span><br><span class="line">100588/usr/share/doc</span><br><span class="line">45080/usr/share/man</span><br><span class="line">25620/usr/share/vim</span><br><span class="line">21648/usr/share/perl5</span><br><span class="line">18832/usr/share/backgrounds</span><br><span class="line">9704/usr/share/i18n</span><br><span class="line">9196/usr/share/cracklib</span><br><span class="line">7888/usr/share/hwdata</span><br><span class="line">6436/usr/share/info</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="对-ls-l-usr-bin-进行文件大小降序排序"><a href="#对-ls-l-usr-bin-进行文件大小降序排序" class="headerlink" title="对 ls -l /usr/bin 进行文件大小降序排序"></a>对 <code>ls -l /usr/bin</code> 进行文件大小降序排序</h3><ul><li><p><code>ls -l</code> 的格式如下，文件大小位于第五个字段</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwxr-xr-x    1 root root       11248 Oct  2  2020 abrt-action-analyze-backtrace</span><br></pre></td></tr></tbody></table></figure></li><li><p>所以命令应该为: <code>ls -l /usr/bin | sort -nrk 5 | head</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos ~]<span class="comment"># ls -l /usr/bin | sort -nrk 5 | head</span></span><br><span class="line">-rwxr-xr-x    1 root root    19615928 Apr 13  2019 mysqlpump</span><br><span class="line">-rwxr-xr-x    1 root root    13574160 Apr 13  2019 mysql_upgrade</span><br><span class="line">-rwxr-xr-x    1 root root    11996472 Apr 13  2019 mysqlbinlog</span><br><span class="line">-rwxr-xr-x    1 root root    11279312 Apr 13  2019 mysql_install_db</span><br><span class="line">-rwxr-xr-x    1 root root    11265296 Apr 13  2019 mysql</span><br><span class="line">-rwxr-xr-x    1 root root    10371032 Apr 13  2019 mysqldump</span><br><span class="line">-rwxr-xr-x    1 root root    10295776 Apr 13  2019 mysqlcheck</span><br><span class="line">-rwxr-xr-x    1 root root    10062016 Apr 13  2019 mysqlslap</span><br><span class="line">-rwxr-xr-x    1 root root    10000960 Apr 13  2019 mysqladmin</span><br><span class="line">-rwxr-xr-x    1 root root     9992344 Apr 13  2019 mysqlimport</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="对多个字段进行排序"><a href="#对多个字段进行排序" class="headerlink" title="对多个字段进行排序"></a>对多个字段进行排序</h3><ul><li><p>准备文件 <code>distros.txt</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SUSE10.212/07/2006</span><br><span class="line">Fedora1011/25/2008</span><br><span class="line">SUSE11.006/19/2008</span><br><span class="line">Ubuntu8.0404/24/2008</span><br><span class="line">Fedora811/08/2007</span><br><span class="line">SUSE10.310/04/2007</span><br><span class="line">Ubuntu6.1010/26/2006</span><br><span class="line">Fedora705/31/2007</span><br><span class="line">Ubuntu7.1010/18/2007</span><br><span class="line">Ubuntu7.0404/19/2007</span><br><span class="line">SUSE10.105/11/2006</span><br><span class="line">Fedora610/24/2006</span><br><span class="line">Fedora905/13/2008</span><br><span class="line">Ubuntu6.0606/01/2006</span><br><span class="line">Ubuntu8.1010/30/2008</span><br><span class="line">Fedora503/20/2006</span><br></pre></td></tr></tbody></table></figure></li><li><p>现在要对 <code>distros.txt</code> 先进行操作系统的排序，再根据版本号排序，我们先看直接 <code>sort</code> 的结果</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos <span class="built_in">sort</span>]<span class="comment"># sort distros.txt</span></span><br><span class="line">Fedora1011/25/2008</span><br><span class="line">Fedora503/20/2006</span><br><span class="line">Fedora610/24/2006</span><br><span class="line">Fedora705/31/2007</span><br><span class="line">Fedora811/08/2007</span><br><span class="line">Fedora905/13/2008</span><br><span class="line">SUSE10.105/11/2006</span><br><span class="line">SUSE10.212/07/2006</span><br><span class="line">SUSE10.310/04/2007</span><br><span class="line">SUSE11.006/19/2008</span><br><span class="line">Ubuntu6.0606/01/2006</span><br><span class="line">Ubuntu6.1010/26/2006</span><br><span class="line">Ubuntu7.0404/19/2007</span><br><span class="line">Ubuntu7.1010/18/2007</span><br><span class="line">Ubuntu8.0404/24/2008</span><br><span class="line">Ubuntu8.1010/30/2008</span><br></pre></td></tr></tbody></table></figure></li><li><p>从以上结果分析，虽然按照操作系统排序了，但是版本号排序结果不正确，<code>10</code> 排在了 <code>5</code> 的前面 ，这里应该按照多个字段排序：先按照第一个字段排序，然后再按照第二个字段进行数字排序: </p><ul><li><code>sort -k1,1 -k2n distros.txt</code> or <code>sort --key=1,1 --key=2n distros.txt</code></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos <span class="built_in">sort</span>]<span class="comment"># sort -k1,1 -k2n  distros.txt</span></span><br><span class="line">Fedora503/20/2006</span><br><span class="line">Fedora610/24/2006</span><br><span class="line">Fedora705/31/2007</span><br><span class="line">Fedora811/08/2007</span><br><span class="line">Fedora905/13/2008</span><br><span class="line">Fedora1011/25/2008</span><br><span class="line">SUSE10.105/11/2006</span><br><span class="line">SUSE10.212/07/2006</span><br><span class="line">SUSE10.310/04/2007</span><br><span class="line">SUSE11.006/19/2008</span><br><span class="line">Ubuntu6.0606/01/2006</span><br><span class="line">Ubuntu6.1010/26/2006</span><br><span class="line">Ubuntu7.0404/19/2007</span><br><span class="line">Ubuntu7.1010/18/2007</span><br><span class="line">Ubuntu8.0404/24/2008</span><br><span class="line">Ubuntu8.1010/30/2008</span><br></pre></td></tr></tbody></table></figure><ul><li>解析:<ul><li><code>-k1,1</code> 表示从第一个字段开始，到第一个字段结束，单纯以第一个字段排序</li></ul></li></ul></li><li><p>如果我们想要对此文本进行一个日期降序排序呢？那我们要指定字段的同时要指定偏移量: </p><ul><li><code>sort -k3.7nbr -k3.1nbr -k3.4nbr distros.txt</code></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos <span class="built_in">sort</span>]<span class="comment"># sort -k3.7nbr -k3.1nbr -k3.4nbr distros.txt</span></span><br><span class="line">Fedora1011/25/2008</span><br><span class="line">Ubuntu8.1010/30/2008</span><br><span class="line">SUSE11.006/19/2008</span><br><span class="line">Fedora905/13/2008</span><br><span class="line">Ubuntu8.0404/24/2008</span><br><span class="line">Fedora811/08/2007</span><br><span class="line">Ubuntu7.1010/18/2007</span><br><span class="line">SUSE10.310/04/2007</span><br><span class="line">Fedora705/31/2007</span><br><span class="line">Ubuntu7.0404/19/2007</span><br><span class="line">SUSE10.212/07/2006</span><br><span class="line">Ubuntu6.1010/26/2006</span><br><span class="line">Fedora610/24/2006</span><br><span class="line">Ubuntu6.0606/01/2006</span><br><span class="line">SUSE10.105/11/2006</span><br><span class="line">Fedora503/20/2006</span><br></pre></td></tr></tbody></table></figure><ul><li>解析: <code>-k3.7nbr</code><ul><li><code>-k3</code> 表示第三段</li><li><code>.7</code> 表示从第7个字符开始</li><li><code>nr</code>: 数字降序排序</li><li><code>b</code>: 去除前面的空白字符，因为第三段前面是有空白字符的，而且每一行的第三段前面的空白字符数量是不确定的</li></ul></li></ul></li></ul><h3 id="对-etc-passwd-文件中的-用户默认shell进行排序"><a href="#对-etc-passwd-文件中的-用户默认shell进行排序" class="headerlink" title="对 /etc/passwd 文件中的 用户默认shell进行排序"></a>对 <code>/etc/passwd</code> 文件中的 用户默认shell进行排序</h3><ul><li><p>该sample主要考察 自定义分隔符的使用 <code>sort</code>命令默认使用空白字符作为分隔符，那么我们这里就需要用到 <code>-t</code> 选项</p></li><li><p>先查看 <code>/etc/passwd</code> 文本文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos <span class="built_in">sort</span>]<span class="comment"># cat /etc/passwd</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line"><span class="built_in">sync</span>:x:5:0:<span class="built_in">sync</span>:/sbin:/bin/sync</span><br><span class="line">shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="line">mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line">games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="line">ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">nobody:x:99:99:Nobody:/:/sbin/nologin</span><br><span class="line">systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin</span><br><span class="line">dbus:x:81:81:System message bus:/:/sbin/nologin</span><br><span class="line">polkitd:x:999:998:User <span class="keyword">for</span> polkitd:/:/sbin/nologin</span><br><span class="line">libstoragemgmt:x:998:997:daemon account <span class="keyword">for</span> libstoragemgmt:/var/run/lsm:/sbin/nologin</span><br><span class="line">rpc:x:32:32:Rpcbind Daemon:/var/lib/rpcbind:/sbin/nologin</span><br><span class="line">ntp:x:38:38::/etc/ntp:/sbin/nologin</span><br><span class="line">abrt:x:173:173::/etc/abrt:/sbin/nologin</span><br><span class="line">sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin</span><br><span class="line">postfix:x:89:89::/var/spool/postfix:/sbin/nologin</span><br><span class="line">chrony:x:997:995::/var/lib/chrony:/sbin/nologin</span><br><span class="line">tcpdump:x:72:72::/:/sbin/nologin</span><br><span class="line">syslog:x:996:994::/home/syslog:/bin/false</span><br><span class="line">lighthouse:x:1000:1000::/home/lighthouse:/bin/bash</span><br><span class="line">www:x:1001:1001::/home/www:/sbin/nologin</span><br><span class="line">mysql:x:1002:1002::/home/mysql:/sbin/nologin</span><br><span class="line">smx:x:1003:1003::/home/smx:/bin/bash</span><br><span class="line"><span class="built_in">test</span>:x:1004:1004::/home/test:/bin/bash</span><br></pre></td></tr></tbody></table></figure></li><li><p>命令: <code>sort -t ':' -k7 /etc/passwd</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos <span class="built_in">sort</span>]<span class="comment"># sort -t ':' -k7 /etc/passwd</span></span><br><span class="line">lighthouse:x:1000:1000::/home/lighthouse:/bin/bash</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">smx:x:1003:1003::/home/smx:/bin/bash</span><br><span class="line"><span class="built_in">test</span>:x:1004:1004::/home/test:/bin/bash</span><br><span class="line">syslog:x:996:994::/home/syslog:/bin/false</span><br><span class="line"><span class="built_in">sync</span>:x:5:0:<span class="built_in">sync</span>:/sbin:/bin/sync</span><br><span class="line">halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="line">abrt:x:173:173::/etc/abrt:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">chrony:x:997:995::/var/lib/chrony:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">dbus:x:81:81:System message bus:/:/sbin/nologin</span><br><span class="line">ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="line">libstoragemgmt:x:998:997:daemon account <span class="keyword">for</span> libstoragemgmt:/var/run/lsm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line">mysql:x:1002:1002::/home/mysql:/sbin/nologin</span><br><span class="line">nobody:x:99:99:Nobody:/:/sbin/nologin</span><br><span class="line">ntp:x:38:38::/etc/ntp:/sbin/nologin</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line">polkitd:x:999:998:User <span class="keyword">for</span> polkitd:/:/sbin/nologin</span><br><span class="line">postfix:x:89:89::/var/spool/postfix:/sbin/nologin</span><br><span class="line">rpc:x:32:32:Rpcbind Daemon:/var/lib/rpcbind:/sbin/nologin</span><br><span class="line">sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin</span><br><span class="line">systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin</span><br><span class="line">tcpdump:x:72:72::/:/sbin/nologin</span><br><span class="line">www:x:1001:1001::/home/www:/sbin/nologin</span><br><span class="line">shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br></pre></td></tr></tbody></table></figure><ul><li>解析: <ul><li><code>-t ':'</code> 指定分隔符为 <code>:</code></li><li><code>-k7</code> 将第7个字段作为排序依据</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> commands </tag>
            
            <tag> linux </tag>
            
            <tag> text commands </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux中的文本处理命令</title>
      <link href="/2022/06/18/linux%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/06/18/linux%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="linux中的文本处理命令"><a href="#linux中的文本处理命令" class="headerlink" title="linux中的文本处理命令"></a>linux中的文本处理命令</h1><h2 id="预览一下linux中一些文本处理命令"><a href="#预览一下linux中一些文本处理命令" class="headerlink" title="预览一下linux中一些文本处理命令"></a>预览一下linux中一些文本处理命令</h2><ul><li><code>cat</code>: 查看和拼接文本文件</li><li><code>sort</code>: 排序文本行</li><li><code>uniq</code>: 报告或忽略重复的行</li><li><code>cut</code>: 从每行中删除部分文件内容</li><li><code>paste</code>: 合并行</li><li><code>join</code>: 连接两个文件中具有公共字段的行</li><li><code>comm</code>: 逐行比较两个已排序的文件</li><li><code>diff</code>: 逐行比较两个文件</li><li><code>patch</code>: 对源文件应用diff文件</li><li><code>tr</code>:  转写或删除字符</li><li><code>sed</code>: 用于文本过滤和转换的流编辑器</li><li><code>aspell</code>: 交互式拼写检查器</li></ul><h2 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h2><ul><li><code>cat</code>: <code>cancatenate files and print on the stanard output</code> 拼接文本并显示到标准输出</li><li><strong>options</strong>:<ul><li><code>-A, --show-all</code>  equivalent to <strong>-vET</strong><ul><li>显示非打印字符和结束字符</li></ul></li><li><code>-n, --number</code> number all output lines<ul><li>显示行号</li></ul></li><li><code>-s, --squeeze-blank</code> suppress repeated empty output lines<ul><li>去除重复的空行（非空白行）</li><li>拼接多个文件时，如果上一个文件末尾有一行空行，下一个文件开头有一行空行，将会合并成一个空行</li></ul></li><li></li></ul></li></ul><h2 id="sort命令"><a href="#sort命令" class="headerlink" title="sort命令"></a>sort命令</h2><ul><li><a href="/2022/06/19/linux%E6%96%87%E6%9C%AC%E5%91%BD%E4%BB%A4%EF%BC%9Asort">linux文本命令：sort</a></li></ul><h2 id="uniq-命令"><a href="#uniq-命令" class="headerlink" title="uniq 命令"></a>uniq 命令</h2><ul><li><a href="/2022/06/19/linux%E6%96%87%E6%9C%AC%E5%91%BD%E4%BB%A4%EF%BC%9Auniq">linux文本命令：uniq</a></li></ul><h2 id="cut命令：切片与切块"><a href="#cut命令：切片与切块" class="headerlink" title="cut命令：切片与切块"></a>cut命令：切片与切块</h2>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> commands </tag>
            
            <tag> linux </tag>
            
            <tag> text commands </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux和windows下文本文件的换行区别</title>
      <link href="/2022/06/18/linux%E5%92%8Cwindows%E4%B8%8B%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E6%8D%A2%E8%A1%8C%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/06/18/linux%E5%92%8Cwindows%E4%B8%8B%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E6%8D%A2%E8%A1%8C%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="linux和windows下文本文件的换行区别"><a href="#linux和windows下文本文件的换行区别" class="headerlink" title="linux和windows下文本文件的换行区别"></a>linux和windows下文本文件的换行区别</h1><ul><li>先说结论：linux下的行是以 <code>\n</code> 结尾来换行，而windows下的行是以 <code>\r\n</code> 结尾来换行</li></ul><h2 id="Linux环境下"><a href="#Linux环境下" class="headerlink" title="Linux环境下"></a>Linux环境下</h2><ul><li><p>我们先在linux环境中创建一个 <code>test.txt </code> 文本文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">34 5</span><br></pre></td></tr></tbody></table></figure></li><li><p>然后我们用命令 <code>cat -A test.txt</code> 查看一下该文本文件内容</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1$</span><br><span class="line">2$</span><br><span class="line">3^I4 5$</span><br></pre></td></tr></tbody></table></figure><ul><li><code>cat -A</code>: 能够打印文本文件中的非打印字符<ul><li><code>$</code>: 表示 换行符<code>\n</code> 10</li><li><code>^I</code>: 表示制表符 <code>\t</code></li><li><code> </code>: 表示空格</li><li><code>^M</code>: 表示回车符 <code>\r</code></li></ul></li><li>可以看到，linux下文本文件以 <code>\n</code> 作为换行依据</li></ul></li></ul><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><ul><li><p>还是创建一个 <code>test.txt</code> 文本文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">34 5</span><br></pre></td></tr></tbody></table></figure></li><li><p>在windows下使用 <code>git bash</code>， 以便于执行 <code>linux</code> 命令 <code>cat -A test.txt</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1^M$</span><br><span class="line">2^M$</span><br><span class="line">3^I4 5</span><br></pre></td></tr></tbody></table></figure><ul><li>可以看出，windows环境下，文本文件的换行是通过 <code>\r\n</code> 实现的</li></ul></li></ul><h2 id="Windows和Linux文本文件相互转换"><a href="#Windows和Linux文本文件相互转换" class="headerlink" title="Windows和Linux文本文件相互转换"></a>Windows和Linux文本文件相互转换</h2><ul><li>linux一般自带 <code>dos2unix</code> and <code>unix2dos</code> 命令</li></ul><h3 id="dos2unix"><a href="#dos2unix" class="headerlink" title="dos2unix"></a>dos2unix</h3><ul><li>使用方法: <code>dos2unix test.txt</code></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat -A test.txt</span><br><span class="line">1^M$</span><br><span class="line">2^M$</span><br><span class="line">3^I4 5</span><br><span class="line">$ dos2unix test.txt</span><br><span class="line">dos2unix: converting file test.txt to Unix format...</span><br><span class="line">$ cat -A test.txt</span><br><span class="line">1$</span><br><span class="line">2$</span><br><span class="line">3^I4 5</span><br></pre></td></tr></tbody></table></figure><ul><li>自己用命令实现: <code>sed -i 's/\r$// test.txt'</code></li></ul><h3 id="unix2dos"><a href="#unix2dos" class="headerlink" title="unix2dos"></a>unix2dos</h3><ul><li>使用方法: <code>unix2dos test.txt</code></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat -A test.txt</span><br><span class="line">1$</span><br><span class="line">2$</span><br><span class="line">3^I4 5</span><br><span class="line">$ unix2dos test.txt</span><br><span class="line">unix2dos: converting file test.txt to DOS format...</span><br><span class="line">$ cat -A test.txt</span><br><span class="line">1^M$</span><br><span class="line">2^M$</span><br><span class="line">3^I4 5</span><br></pre></td></tr></tbody></table></figure><ul><li>自己用命令实现: <ul><li>不完善，有bug: <code>sed -i 's/$/\r/' test.txt</code>，最后一行有问题</li></ul></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://www.cyberciti.biz/faq/howto-unix-linux-convert-dos-newlines-cr-lf-unix-text-format/"></a><a href="https://www.cyberciti.biz/faq/howto-unix-linux-convert-dos-newlines-cr-lf-unix-text-format/">HowTo: UNIX / Linux Convert DOS Newlines CR-LF to Unix/Linux Format</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dos命令del与rd</title>
      <link href="/2022/06/18/dos%E5%91%BD%E4%BB%A4del%E4%B8%8Erd/"/>
      <url>/2022/06/18/dos%E5%91%BD%E4%BB%A4del%E4%B8%8Erd/</url>
      
        <content type="html"><![CDATA[<h1 id="dos命令del与rd"><a href="#dos命令del与rd" class="headerlink" title="dos命令del与rd"></a>dos命令del与rd</h1><h2 id="del命令"><a href="#del命令" class="headerlink" title="del命令"></a>del命令</h2><ul><li>del: 删除文件</li><li>options:<ul><li><code>/q</code>: 安静模式，删除全局通配符时，不要求确认</li><li><code>/s</code>: 递归删除子目录中的文件（但是不会删除子目录）</li></ul></li><li>notes: <ul><li><code>/q /s</code> 要这么用，不能连着用: <code>/qs</code></li></ul></li></ul><h2 id="rd命令"><a href="#rd命令" class="headerlink" title="rd命令"></a>rd命令</h2><ul><li><code>rd</code> 是 <code>rmdir</code> 的缩写，两个命令是等价的，用于删除文件夹和文件</li><li>options:<ul><li><code>/q</code>: 安静模式，带 <code>/s</code> 删除目录树时不要求确认</li><li><code>/s</code>: 递归删除子目录和子文件</li></ul></li><li>notes:<ul><li><code>/q /s</code> 要这么用，不能连着用: <code>/qs</code></li></ul></li></ul><h2 id="questions"><a href="#questions" class="headerlink" title="questions"></a>questions</h2><ul><li>删除某个当前目录下所有的日志文件（以.log结尾）: <code>del /q *.log</code></li><li>删除当前目录下所有文件: <code>del /q *</code></li><li><code>del /q /s *</code> 会发生什么：删除当前目录下所有文件和递归删除子目录下的所有文件（不会删除子目录）</li><li>删除test文件夹: <code>rd /q /s  test</code></li></ul><h2 id="practices"><a href="#practices" class="headerlink" title="practices"></a>practices</h2><ul><li><p>准备 <code>prepare.bat</code></p><figure class="highlight bat"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">md</span> test</span><br><span class="line"><span class="built_in">cd</span> test </span><br><span class="line"><span class="built_in">echo</span> <span class="number">1</span>.txt &gt; <span class="number">1</span>.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="number">2</span>.txt &gt; <span class="number">2</span>.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="number">3</span>.txt &gt; <span class="number">3</span>.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="number">1</span>.txt &gt; <span class="number">1</span>.bak</span><br><span class="line"><span class="built_in">md</span> subfolder</span><br><span class="line"><span class="built_in">cd</span> subfolder</span><br><span class="line"><span class="built_in">echo</span> sub.txt &gt; sub.txt</span><br></pre></td></tr></tbody></table></figure></li><li><p>删除 test 目录下的所有的 以<code>txt</code>结尾文件: <code>del /q *.txt</code></p></li><li><p>删除 test 目录下的所有文件(包括子文件夹中的文件，不删除目录): <code>del /q /s *</code></p></li><li><p>删除test目录: <code>rd /q /s test</code></p></li></ul><h2 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h2><ul><li><p>如何以不显示控制台的方式执行一个bat脚本:</p><ol><li><p>使用vb脚本去运行bat脚本</p><figure class="highlight vb"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> shell=wscript.createObject(<span class="string">"wscript.shell"</span>)</span><br><span class="line">run=shell.Run(<span class="string">"F:\softwares\quick\scripts\work\test.bat"</span>, <span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><ul><li><code>0</code>: 不显示控制台</li><li><code>1</code>: 显示控制台</li></ul></li><li><p>将bat脚本转成exe文件</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> dos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dos </tag>
            
            <tag> commands </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows和linux中文本文件中的换行</title>
      <link href="/2022/06/17/windows%E5%92%8Clinux%E4%B8%AD%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C/"/>
      <url>/2022/06/17/windows%E5%92%8Clinux%E4%B8%AD%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux sed命令，强大的文本处理命令</title>
      <link href="/2022/06/16/linux-sed%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/06/16/linux-sed%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="linux-sed命令，强大的文本处理命令"><a href="#linux-sed命令，强大的文本处理命令" class="headerlink" title="linux:sed命令，强大的文本处理命令"></a>linux:sed命令，强大的文本处理命令</h1><h2 id="sed命令简介"><a href="#sed命令简介" class="headerlink" title="sed命令简介"></a>sed命令简介</h2><ul><li>在 <code>&lt;&lt;Linux命令、编辑器与shell编程&gt;&gt;</code> 这本书中，将 <code>sed</code> 看作是一个编辑器，可见该命令功能的强大</li><li>sed：<code>stream editor</code> 流编辑器，是一个批处理（非交互式）编辑器。它可以变换来自文件或标准输入和输入流。它常被用作管道中的过滤器。由于sed仅仅对其输入扫描一次，因此它比其他交互式编辑器(如 ed)更加高效。</li><li>sed 有多种版本，linux上一般是 <code>GNU sed</code>，mac上用的是 <code>BSD sed</code>，本文除非特别说明，否则默认为 <code>GNU sed</code></li></ul><h3 id="sed命令格式"><a href="#sed命令格式" class="headerlink" title="sed命令格式"></a>sed命令格式</h3><ul><li>命令行语法:<ol><li><code>sed [-n] program [file-list]</code></li><li><code>sed [-n] -f program-file [file-list]</code></li></ol></li><li>第一种直接写命令，第二种是将命令写在文件中。</li></ul><h3 id="sed命令可以做什么"><a href="#sed命令可以做什么" class="headerlink" title="sed命令可以做什么"></a>sed命令可以做什么</h3><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li><p><code>a:append</code> 追加文本 (追加换行符和文本)</p><ul><li><p>文本文件：<code>test</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">my name is </span><br><span class="line">smx</span><br></pre></td></tr></tbody></table></figure></li><li><p>命令: <code>sed 'a yes' test</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">yes</span><br><span class="line">my name is </span><br><span class="line">yes</span><br><span class="line">smx</span><br><span class="line">yes</span><br></pre></td></tr></tbody></table></figure></li><li><p>sed命令始终输出追加命令: <code>sed -n 'a yes' test</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yes</span><br><span class="line">yes</span><br><span class="line">yes</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习:"></a>练习:</h2><ol><li>删除文本文件 <code>test</code> 中的空行</li><li>删除文本文件 <code>test2</code> 中的空白行</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mvvm:wpf事件binding command</title>
      <link href="/2022/06/16/mvvm-wpf%E4%BA%8B%E4%BB%B6binding-command/"/>
      <url>/2022/06/16/mvvm-wpf%E4%BA%8B%E4%BB%B6binding-command/</url>
      
        <content type="html"><![CDATA[<h1 id="MVVM-WPF事件Binding-Command"><a href="#MVVM-WPF事件Binding-Command" class="headerlink" title="MVVM:WPF事件Binding Command"></a>MVVM:WPF事件Binding Command</h1><ul><li><p>我们知道 <code>Button</code> 控件有 <code>Command</code> 依赖属性，可以用来绑定我们定义在 <code>ViewModel</code> 中的 <code>RelayCommand</code>，当 <code>Button</code> 被点击的时候就会自动执行 我们定义的<code>RelayCommand</code></p></li><li><p>但是其他控件比如 <code>Label</code> 这些没有 <code>Command</code> 依赖属性的怎么绑定 <code>RelayCommand</code>，比如 <code>Label</code>的左击事件怎么绑定 <code>RelayCommand</code>。</p></li><li><p>这个时候就要用到 <code>EventTrigger</code> and <code>InvokeCommandAction</code></p><ul><li>以前我们需要找到 <code>System.Windows.Interactivity.dll</code> 引入我们的项目</li><li>现在微软退出了新的nuget包，我们以新的nuget包示例</li></ul></li><li><p>引入 nuget 包： <code>Microsoft.Xaml.Behaviors.Wpf</code></p></li><li><p>xaml代码:</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Window</span> <span class="attr">x:Class</span>=<span class="string">"CommandBindingEvent.MainWindow"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns</span>=<span class="string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:x</span>=<span class="string">"http://schemas.microsoft.com/winfx/2006/xaml"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:behaviors</span>=<span class="string">"http://schemas.microsoft.com/xaml/behaviors"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Grid</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Label</span> <span class="attr">Content</span>=<span class="string">"Hello WPF!"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">behaviors:Interaction.Triggers</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">behaviors:EventTrigger</span> <span class="attr">EventName</span>=<span class="string">"MouseLeftButtonDown"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">behaviors:InvokeCommandAction</span> <span class="attr">Command</span>=<span class="string">"{Binding HelloCmd}"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">behaviors:EventTrigger</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">behaviors:Interaction.Triggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Window</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>ViewModel代码:</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RelayArgCommand _helloCmd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> RelayArgCommand HelloCmd</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> _helloCmd ?? (_helloCmd = <span class="keyword">new</span> RelayArgCommand((e) =&gt;</span><br><span class="line">                                                             {</span><br><span class="line">                                                                 MessageBox.Show(<span class="string">"hello wpf!"</span>);</span><br><span class="line">                                                             }));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>但是，经过断点调试，我们发现 <code>Command</code> 中的 <code>e</code> 为null，事件一般有两个参数: <code>private void XXX_OnXX(object sender, RoutedEventArgs e)</code>，我们想要通过这两个参数进行其他操作怎么办？</p><ul><li><p><img src="/..%5Cimages%5Cmvvmwpf%E4%BA%8B%E4%BB%B6binding_command%5C1.jpg" alt="image"></p></li><li><p><code>InvokeCommandAction</code> 中需要设置一个参数即可，<code>sender</code> 可通过 <code>e.Source</code> 获得</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;behaviors:InvokeCommandAction Command="{Binding HelloCmd}" PassEventArgsToCommand="True" /&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li><img src="/..%5Cimages%5Cmvvmwpf%E4%BA%8B%E4%BB%B6binding_command%5C2.jpg" alt="image2"></li></ul></li></ul></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/baby-Jie/blog_codes/tree/main/dotnet/wpf/CommandBindingEvent">code</a></li><li><a href="https://devblogs.microsoft.com/dotnet/open-sourcing-xaml-behaviors-for-wpf/">behaviors</a></li><li><a href="https://www.nuget.org/packages/Microsoft.Xaml.Behaviors.Wpf/">nuget</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> wpf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wpf </tag>
            
            <tag> mvvm </tag>
            
            <tag> binding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速打开环境变量面板</title>
      <link href="/2022/06/15/%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%9D%A2%E6%9D%BF/"/>
      <url>/2022/06/15/%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%9D%A2%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="快速打开环境变量面板"><a href="#快速打开环境变量面板" class="headerlink" title="快速打开环境变量面板"></a>快速打开环境变量面板</h1><ul><li>如果想要添加一个环境变量你会怎么做？<ul><li>使用命令行 <code>setx JAVA_HOME d:\\libs\\jdk</code><ul><li>单纯的加环境变量还好，但是如果往 <code>PATH</code> 中添加路径有两个致命的缺点<ol><li>命令没写好，导致PATH路径被覆盖</li><li>PATH长度大于1024，不可写入</li></ol></li></ul></li><li>使用图形化界面<ul><li>打开设置 -&gt; 找到关于 -&gt; 点击高级系统设置 -&gt; 选择高级tab -&gt; 点击环境变量</li><li><img src="/../images/%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%9D%A2%E6%9D%BF/%E6%89%93%E5%BC%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%9D%A2%E6%9D%BFui.jpg" alt="image"></li></ul></li></ul></li></ul><h2 id="使用命令行打开"><a href="#使用命令行打开" class="headerlink" title="使用命令行打开"></a>使用命令行打开</h2><ul><li><p>可以看出以上两种方式都不太便捷，那么，有没有比较快捷的方法呢？有，你可以执行以下命令(运行处<kbd>Win</kbd>+<kbd>r</kbd>):</p><ul><li><code>rundll32 sysdm.cpl,EditEnvironmentVariables</code></li><li><img src="/../images/%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%9D%A2%E6%9D%BF/%E6%89%93%E5%BC%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%9D%A2%E6%9D%BF%E5%BF%AB%E6%8D%B7%E5%91%BD%E4%BB%A4.jpg" alt="image"></li></ul></li><li><p>但是这么长的命令，又难记，又费时间怎么办？写一个脚本执行即可 <code>env.bat</code></p><figure class="highlight bat"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">start</span> /b rundll32 sysdm.cpl,EditEnvironmentVariables</span><br></pre></td></tr></tbody></table></figure></li><li><p>然后将这个脚本创建一个快捷方式，名字就命名为 <code>env</code>, 随后将这个快捷方式放到，环境变量PATH路径中</p><ul><li><img src="/../images/%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%9D%A2%E6%9D%BF/env.jpg" alt="env"></li><li><img src="/../images/%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%9D%A2%E6%9D%BF/env2.jpg" alt="env"></li></ul></li><li><p>接下来我们只要在 运行处 键入: <code>env</code> 命令就可快速打开变量面板了</p><ul><li><img src="/../images/%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%9D%A2%E6%9D%BF/env3.jpg" alt="env"></li></ul></li></ul><h2 id="新方法：别名的方式"><a href="#新方法：别名的方式" class="headerlink" title="新方法：别名的方式"></a>新方法：别名的方式</h2><ul><li><p><strong>doskey</strong> 类似于linux中的<code>alias</code></p></li><li><p>在cmd命令行窗口中 键入 <code>doskey var=rundll32 sysdm.cpl,EditEnvironmentVariables</code>，随后就可以通过 <code>var</code> 直接打开 环境变量面板，但是这种方式只能在当前窗口中有效。</p></li><li><p>永久有效</p><ul><li><p>创建一个 <code>bat</code> 脚本 <strong>start.bat</strong>：</p><figure class="highlight bat"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">doskey</span> var=rundll32 sysdm.cpl,EditEnvironmentVariables</span><br></pre></td></tr></tbody></table></figure></li><li><p>打开注册表: <code>regedit</code></p><ul><li>找到 <code>hkc\software\microsoft\command processor</code> 创建一个 <code>AutoRun</code> 的键，值为 <strong>REG_SIZE</strong> 类型，值为: <code>F:\softwares\quick\scripts\start.bat</code></li></ul></li><li><p>再次打开cmd命令窗口，测试 <code>var</code> 命令是否能够直接打开环境变量面板。</p></li><li><p>但是这种方式不能直接在运行中使用 配置方面倒是简单了，但是没有上面的使用的方便</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> dos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dos </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux程序以后台方式启动</title>
      <link href="/2022/06/14/linux%EF%BC%9A%E7%A8%8B%E5%BA%8F%E4%BB%A5%E5%90%8E%E5%8F%B0%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8/"/>
      <url>/2022/06/14/linux%EF%BC%9A%E7%A8%8B%E5%BA%8F%E4%BB%A5%E5%90%8E%E5%8F%B0%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC： 请求参数详解</title>
      <link href="/2022/06/13/SpringMVC%EF%BC%9A%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/06/13/SpringMVC%EF%BC%9A%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC：-请求参数详解"><a href="#SpringMVC：-请求参数详解" class="headerlink" title="SpringMVC： 请求参数详解"></a>SpringMVC： 请求参数详解</h1><ul><li>Http请求参数分为两种<ol><li>url拼接参数</li><li>请求体参数</li></ol></li></ul><h2 id="code-准备"><a href="#code-准备" class="headerlink" title="code 准备"></a>code 准备</h2><ul><li><p><code>User.java</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>{</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="获取请求参数的五种方式"><a href="#获取请求参数的五种方式" class="headerlink" title="获取请求参数的五种方式"></a>获取请求参数的五种方式</h2><h3 id="SevletApi方式获取请求参数"><a href="#SevletApi方式获取请求参数" class="headerlink" title="SevletApi方式获取请求参数"></a>SevletApi方式获取请求参数</h3><ul><li><p>在请求方法种添加 <code>HttpServletRequest</code> 类型参数，并通过调用 <code>requestParam</code> 获取参数，此方法比较原始.</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping("/user01")</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">servletApi</span><span class="params">(HttpServletRequest request)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> request.getParameter(<span class="string">"userName"</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> request.getParameter(<span class="string">"sex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUserName(userName);</span><br><span class="line">    user.setSex(sex);</span><br><span class="line">    user.setDescription(<span class="string">"servletApi in ParameterGetController"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul><li><p><code>Get/Post/Put http://localhost:9000/user01</code> body: none</p><ul><li><p>reponse:</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sex"</span><span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">"servletApi in ParameterGetController"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>因为没有带拼接url参数，所以通过 <code>request.getParam(key)</code> 获取到的值都为null</p></li></ul></li><li><p><code>Get/Post/Put http://localhost:9000/user01?userName=smx&amp;sex=male</code> body:none</p><ul><li><p>response:</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="string">"smx"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sex"</span><span class="punctuation">:</span> <span class="string">"male"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">"servletApi in ParameterGetController"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>因为带了拼接url参数，所以通过 <code>request.getParam(key)</code> 可以获取到对应的值</p></li></ul></li><li><p>带有body的请求，因为该方法只用了 <code>request.getParam(key)</code> 只能获取拼接url参数，所以这里就举例带有body的请求了。</p></li></ul><h3 id="方法同名参数接收请求参数"><a href="#方法同名参数接收请求参数" class="headerlink" title="方法同名参数接收请求参数"></a>方法同名参数接收请求参数</h3><ul><li><p>在请求方法中，使用和请求参数同名的参数:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping("/user02")</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">funParam</span><span class="params">(String userName, String sex)</span> {</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUserName(userName);</span><br><span class="line">    user.setSex(sex);</span><br><span class="line">    user.setDescription(<span class="string">"funParam in ParameterGetController"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><ul><li><p><code>Get/Post/Put http://localhost:9000/user02</code> body:none</p><ul><li><p>response: </p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sex"</span><span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">"funParam in ParameterGetController"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>因为请求既没有拼接参数，也没有body，自然接收到的参数为null</p></li></ul></li><li><p><code>Get/Post/Put http://localhost:9000/user02?userName=smx&amp;sex=male</code> body: none</p><ul><li><p>response:</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="string">"smx"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sex"</span><span class="punctuation">:</span> <span class="string">"male"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">"funParam in ParameterGetController"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>该方法可以接收拼接参数</p></li></ul></li><li><p><code>Post/Put http://localhost:9000/user02</code> <code>Content-Type: application/x-www-form-urlencoded</code></p><ul><li><p>body:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userName:smx_urlencoded</span><br><span class="line">sex:male_urlencoded</span><br></pre></td></tr></tbody></table></figure></li><li><p>response:</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="string">"smx_urlencoded"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sex"</span><span class="punctuation">:</span> <span class="string">"male_urlencoded"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">"funParam in ParameterGetController"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>可见，该方法不仅能接收拼接参数，而且还能接收 <code>body</code> 参数 (post or put method, get方法不能接收body参数)</p></li></ul></li><li><p>那么请求既带拼接参数，又带body参数又该怎么样呢？请求 <code>POST http://localhost:9000/user02?userName=smx&amp;sex=male</code></p><ul><li><p><code>Content-Type: application/x-www-form-urlencoded</code></p></li><li><p>body:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userName:smx_urlencoded</span><br><span class="line">sex:male_urlencoded</span><br></pre></td></tr></tbody></table></figure></li><li><p>response:</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="string">"smx,smx_urlencoded"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sex"</span><span class="punctuation">:</span> <span class="string">"male,male_urlencoded"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">"funParam in ParameterGetController"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>从以上的response可以看到，拼接参数和body参数同名参数自动拼接成一个字符串</p></li><li><p>那么，如果拼接参数和body参数同名且值相同会怎么样？</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="string">"smx,smx"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sex"</span><span class="punctuation">:</span> <span class="string">"male,male"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">"funParam in ParameterGetController"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="使用-RequestParam指定参数名"><a href="#使用-RequestParam指定参数名" class="headerlink" title="使用 @RequestParam指定参数名"></a>使用 @RequestParam指定参数名</h2><ul><li><p>在请求方法中，使用 <code>@RequestParam</code>  指定参数的名字</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping("/user03")</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">funNamedParam</span><span class="params">(<span class="meta">@RequestParam("userName")</span> String name, <span class="meta">@RequestParam("sex")</span> String gender)</span> {</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUserName(name);</span><br><span class="line">    user.setSex(gender);</span><br><span class="line">    user.setDescription(<span class="string">"funNamedParam in ParameterGetController"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>有一点需要注意：<code>RequestParam</code> 中的 <code>required</code> 默认为true，也就是说，一旦被 <code>@RequestParam</code> 标记的参数一定要提供，否咋报错，当然你也可以手动将 <code>required</code>  设置为 <code>false</code> : <code>@RequestParam(value="userName", required=false) String name</code></p></li></ul><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><ul><li>和 <strong>方法同名参数接收请求参数</strong> 测试一致</li></ul><h2 id="使用Bean对象接收参数"><a href="#使用Bean对象接收参数" class="headerlink" title="使用Bean对象接收参数"></a>使用Bean对象接收参数</h2><ul><li><p>在请求方法中，直接使用bean对象去接收请求的参数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping("/user04")</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">beanParam</span><span class="params">(User user)</span> {</span><br><span class="line">    user.setDescription(<span class="string">"beanParam in ParameterGetController"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h3><ul><li>与以上测试一致</li></ul><h2 id="使用-RequestBody-来接收-json数据"><a href="#使用-RequestBody-来接收-json数据" class="headerlink" title="使用 @RequestBody 来接收 json数据"></a>使用 @RequestBody 来接收 json数据</h2><ul><li><p>在请求方法中，直接使用bean对象并且使用 @RequestBody来标记，接收body的json数据</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping("/user05")</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">jsonRequestBody</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> {</span><br><span class="line">    user.setDescription(<span class="string">"jsonRequestBody in ParameterGetController"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>@RequestBody</code>: 主要用来接收前端传递给后端的json字符串种的数据</p><ul><li>一个请求，只有一个RequestBody, 可以有多个 RequestParam</li></ul></li><li><p><code>@RequestBody</code> 只能接收 <code>Content-Type</code> 为 <code>application/json</code> 的请求（body为json)，不会接收 url拼接参数</p></li></ul><h3 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h3><ul><li><p><code>Get/Post/Put http://localhost:9000/user05</code> <code>Content-Type: application/json</code></p><ul><li><p>body:</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="string">"smx_json"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sex"</span><span class="punctuation">:</span> <span class="string">"male_json"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>response:</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="string">"smx_json"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sex"</span><span class="punctuation">:</span> <span class="string">"male_json"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">"jsonRequestBody in ParameterGetController"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="请求体内容"><a href="#请求体内容" class="headerlink" title="请求体内容"></a>请求体内容</h2><ul><li><p>首先我们要在Headers中添加一个 key，为 <code>Content-Type</code>, 表明我们请求体(body)的内容类型 接下来我们仔细研究一下这个 <code>Content-Type</code></p></li><li><p><code>Content-Type</code></p><ul><li><p><code>application/json</code>: 表明 <code>body</code> 内容就是json字符串</p></li><li><p><code>application/x-www-form-urlencoded</code>: 表单提交就是以这种方式，body内容为key value值的拼接，例如: <code>userName=smx&amp;sex=male</code></p></li><li><p><code>multipart/form-data</code></p><ul><li><p><code>Content-Type</code> 中不仅要设置为 <code>multipart/form-data</code> 还要设置自定义边界</p><ul><li><p>例如: <code>Content-Type: multipart/form-data; boundary=--smx</code></p></li><li><p>那么 body 就应该设置为</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">----smx</span><br><span class="line">Content-Disposition: form-data; name="userName"</span><br><span class="line"></span><br><span class="line">smx</span><br><span class="line">----smx</span><br><span class="line">Content-Disposition: form-data; name="sex"</span><br><span class="line"></span><br><span class="line">male</span><br><span class="line">----smx--</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>html中利用form来提交 <code>form-data</code> 数据</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span> <span class="attr">action</span>=<span class="string">"http://localhost:9000/user04"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">value</span>=<span class="string">"smx"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>性别:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"male"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>查看请求源码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryvGgpig5EBnllnkJb</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryvGgpig5EBnllnkJb</span><br><span class="line">Content-Disposition: form-data; name="userName"</span><br><span class="line"></span><br><span class="line">smx</span><br><span class="line">------WebKitFormBoundaryvGgpig5EBnllnkJb</span><br><span class="line">Content-Disposition: form-data; name="sex"</span><br><span class="line"></span><br><span class="line">male</span><br><span class="line">------WebKitFormBoundaryvGgpig5EBnllnkJb--</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th align="center">参数请求方式</th><th align="center">servlet api方式获取参数</th><th align="center">同名参数获取方式</th><th align="center">指定参数名称获取方式</th><th align="center">bean对象方式</th><th align="center">@RequestBody方式</th><th align="center">get请求</th><th align="center">post请求</th><th align="center">put请求</th></tr></thead><tbody><tr><td align="center">url拼接参数</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">form-data</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">x-www-form-urlencoded</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">application/json</td><td align="center">×</td><td align="center">×</td><td align="center">×</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> RequestBody </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux命令tar的使用</title>
      <link href="/2022/06/08/linux%E5%91%BD%E4%BB%A4tar%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/06/08/linux%E5%91%BD%E4%BB%A4tar%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="linux命令tar的使用"><a href="#linux命令tar的使用" class="headerlink" title="linux命令tar的使用"></a>linux命令tar的使用</h1><ul><li>tar命令用于打包、解包、压缩、解压缩文件，能够制作出linux系统中常见的 <code>.tar</code>、<code>.tar.gz</code>、<code>.tar.bz2</code>等格式的压缩包文件。</li></ul><h2 id="options"><a href="#options" class="headerlink" title="options"></a>options</h2><ul><li><code>-c</code>: 建立新的备份文件</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> commands </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式：单例模式</title>
      <link href="/2022/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式：单例模式"><a href="#设计模式：单例模式" class="headerlink" title="设计模式：单例模式"></a>设计模式：单例模式</h1><ul><li>单例模式是一种非常简单且容易理解的设计模式。顾名思义，单例即单一的实例。确切地讲，就是指在某个系统中只存在一个实例。例如宇宙中只有一个太阳。</li><li>单例模式一般有两种实现方式：饿汉式和饱汉式</li><li>创建单例模式一般遵循这几个规则:<ol><li>构造函数私有化</li><li>提供获取单例的方法，暴露给外部使用</li></ol></li></ul><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><ul><li><p>顾名思义，就是一开始就创建好实例对象</p></li><li><p>code:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> smx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-06-08 21:41</span></span><br><span class="line"><span class="comment"> * 单例模式: 饿汉式</span></span><br><span class="line"><span class="comment"> * 首先要将构造函数改成私有，防止破坏单例性</span></span><br><span class="line"><span class="comment"> * 直接new一个静态的实例对象</span></span><br><span class="line"><span class="comment"> * 最后通过一个方法 getInstance 来获取单例</span></span><br><span class="line"><span class="comment"> * 为什么不直接 public static SingletonModel instance;  防止对 instance 的修改 破坏单例性</span></span><br><span class="line"><span class="comment"> * 因为是饿汉式，所以是线程安全的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonModel</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonModel</span><span class="params">()</span>{}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonModel</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonModel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonModel <span class="title function_">getInstance</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="饱汉式"><a href="#饱汉式" class="headerlink" title="饱汉式"></a>饱汉式</h2><ul><li><p>简单的饱汉式，第一次用的时候再创建实例，但是在多线程环境下可能会有多个实例，非线程安全</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> smx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-06-08 21:50</span></span><br><span class="line"><span class="comment"> * 饱汉式单例模式：就是第一次用的时候再创建</span></span><br><span class="line"><span class="comment"> * 这种方法在多线程环境下可能出现问题，线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonModel2</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonModel2</span><span class="params">()</span>{}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonModel2 instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonModel2 <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 先判断，是否为null，为null再创建</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">SingletonModel2</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>加锁的饱汉式，虽然是线程安全了，但是十分影响性能，因为每次获取实例都要加锁</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> smx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-06-08 21:52</span></span><br><span class="line"><span class="comment"> * 饱汉式：加锁，线程安全</span></span><br><span class="line"><span class="comment"> * 但是每次获取都要加锁导致性能下降</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonModel3</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonModel3</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonModel3 instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SingletonModel3 <span class="title function_">getInstance</span><span class="params">()</span>{</span><br><span class="line">        <span class="comment">// 每次获取都要加锁，十分影响性能</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">SingletonModel3</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>双重锁、双检锁饱汉式，外层放宽入口，保证线程并发的高效性；内层加锁同步，保证实例化的单次运行，如此里应外合，不仅达到了单例模式的效果，还完美保证了构建过程的运行效率</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> smx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-06-08 21:55</span></span><br><span class="line"><span class="comment"> * 饱汉式：双重锁，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonModel4</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonModel4</span><span class="params">()</span>{}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonModel4 instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonModel4 <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 外层放开入口，保证线程并发的高效性</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonModel4.class) {</span><br><span class="line">                <span class="comment">// 内层加锁同步，保证实例化的单一运行</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingletonModel4</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>除了以上两种实现单例的方式，还有内部类方式等等…</li><li>在实际开发中，最常用的还是饿汉式单例，因为单例迟早是要被实例化的，延迟加载的意义并不大，加锁解锁反而是一种资源的浪费，同步会降低CPU的利用率，使用不当的话反而会带来不必要的风险。越简单的包容性越强，越复杂的反而越容易出错。所以我建议还是饿汉式模式优先。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu下apt的使用</title>
      <link href="/2022/06/08/ubuntu%E4%B8%8Bapt%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/06/08/ubuntu%E4%B8%8Bapt%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu下apt的使用"><a href="#Ubuntu下apt的使用" class="headerlink" title="Ubuntu下apt的使用"></a>Ubuntu下apt的使用</h1><h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><ul><li>安装依赖有版本冲突时: <code>aptitude install xxx</code></li><li>修复已经 <code>failed/broken</code> 包: <code># apt -f install</code></li></ul><h2 id="modify"><a href="#modify" class="headerlink" title="modify"></a>modify</h2><ul><li>更新: <code>apt update</code></li><li>升级: <code>apt upgrade</code></li><li>查看可更新的packages: <code>apt list --upgradable</code></li></ul><h2 id="query"><a href="#query" class="headerlink" title="query"></a>query</h2><ul><li><p>查询已经安装的包: <code>dpkg --list | grep &lt;package-name&gt;</code></p></li><li><p>查询可安装的包列表: <code>apt list</code>，如果已安装的包会在最后显示 <code>installed</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">smx@ubuntu:~/jdk/test$ apt list | grep net-tools</span><br><span class="line"></span><br><span class="line">WARNING: apt does not have a stable CLI interface. Use with caution <span class="keyword">in</span> scripts.</span><br><span class="line"></span><br><span class="line">ddnet-tools/impish 15.5.4-1ubuntu1 amd64</span><br><span class="line">net-tools/impish,now 1.60+git20181103.0eebece-1ubuntu2 amd64 [installed]</span><br><span class="line">net-tools/impish 1.60+git20181103.0eebece-1ubuntu2 i386</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><ul><li><p><code>remove/purge</code>都可以用来卸载包使用, <code>purge</code> 会同时删除配置文件，而<code>remove</code> 不会</p><ul><li><code># apt remove &lt;package-name&gt;</code></li><li><code># apt purge &lt;package-name&gt;</code></li></ul></li><li><p><code>remove/purge</code>除了能够卸载包，还可以安装包</p><ul><li><code># apt &lt;remove/purge&gt; &lt;package-name&gt;+</code></li></ul></li><li><p>clear the cache of <code>old/outdate</code> packages with:  <code># apt clean</code></p></li><li><p>卸载非必要的包: <code># apt auto remove</code></p></li></ul><hr><h2 id="apt-package-samples"><a href="#apt-package-samples" class="headerlink" title="apt package samples"></a>apt package samples</h2><ul><li><code>apt install aptitude</code></li><li><code>apt install vim</code></li><li><code>apt install openjdk-8-jdk</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> software </tag>
            
            <tag> apt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdk的安装</title>
      <link href="/2022/06/07/jdk%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2022/06/07/jdk%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="jdk的安装"><a href="#jdk的安装" class="headerlink" title="jdk的安装"></a>jdk的安装</h1><h2 id="jdk的下载"><a href="#jdk的下载" class="headerlink" title="jdk的下载"></a>jdk的下载</h2>]]></content>
      
      
      <categories>
          
          <category> software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无限背包问题</title>
      <link href="/2022/06/02/%E6%97%A0%E9%99%90%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2022/06/02/%E6%97%A0%E9%99%90%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>01背包问题</title>
      <link href="/2022/06/01/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2022/06/01/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>wpf绑定失败回滚</title>
      <link href="/2022/05/31/wpf%E7%BB%91%E5%AE%9A%E5%A4%B1%E8%B4%A5%E5%9B%9E%E6%BB%9A/"/>
      <url>/2022/05/31/wpf%E7%BB%91%E5%AE%9A%E5%A4%B1%E8%B4%A5%E5%9B%9E%E6%BB%9A/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>链表中的节点每k个翻转</title>
      <link href="/2022/05/30/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%AF%8Fk%E4%B8%AA%E7%BF%BB%E8%BD%AC/"/>
      <url>/2022/05/30/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%AF%8Fk%E4%B8%AA%E7%BF%BB%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="链表中的节点每k个一组翻转"><a href="#链表中的节点每k个一组翻转" class="headerlink" title="链表中的节点每k个一组翻转"></a><strong>链表中的节点每k个一组翻转</strong></h1><ul><li><a href="https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=295&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=/exam/oj">题目链接</a></li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样<br>你不能更改节点中的值，只能更改节点本身。</p><p>数据范围： \ 0 \le n \le 2000 0≤<em>n</em>≤2000 ， 1 \le k \le 20001≤<em>k</em>≤2000 ，链表中每个元素都满足 0 \le val \le 10000≤<em>v<strong>a</strong>l</em>≤1000<br>要求空间复杂度 O(1)<em>O</em>(1)，时间复杂度 O(n)<em>O</em>(<em>n</em>)</p><p>例如：</p><p>给定的链表是 1\to2\to3\to4\to51→2→3→4→5</p><p>对于 k = 2<em>k</em>=2 , 你应该返回 2\to 1\to 4\to 3\to 52→1→4→3→5</p><p>对于 k = 3<em>k</em>=3 , 你应该返回 3\to2 \to1 \to 4\to 53→2→1→4→5</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{1,2,3,4,5},2</span><br></pre></td></tr></tbody></table></figure><p>复制</p><p>返回值：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{2,1,4,3,5}</span><br></pre></td></tr></tbody></table></figure><p>复制</p><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{},1</span><br></pre></td></tr></tbody></table></figure><p>复制</p><p>返回值：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{}</span><br></pre></td></tr></tbody></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li><p>和 <strong>链表内指定区间反转</strong> 一样，首先写一个函数，反转链表前k个节点</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 首先计算该链表的长度len</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode* head2 = head, *tail = head;</span><br><span class="line">    <span class="keyword">while</span> (head2) {head2=head2-&gt;next; len++;}</span><br><span class="line">    <span class="comment">// 长度不足k个节点，直接返回，不逆转</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; k) <span class="keyword">return</span> head;</span><br><span class="line">    head2 = head-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> next = head2-&gt;next;</span><br><span class="line">        head2-&gt;next = head;</span><br><span class="line">        head = head2;</span><br><span class="line">        head2 = next;</span><br><span class="line">    }</span><br><span class="line">    tail-&gt;next = head2;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>接下来的操作很简单，只需要在函数返回前 对剩下来的节点再进行 反转前k个节点 操作即可</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail-&gt;next = <span class="built_in">reverseKGroup</span>(head2, k);</span><br></pre></td></tr></tbody></table></figure></li><li><p>完整代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 首先计算该链表的长度len</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode* head2 = head, *tail = head;</span><br><span class="line">    <span class="keyword">while</span> (head2) {head2=head2-&gt;next; len++;}</span><br><span class="line">    <span class="comment">// 长度不足k个节点，直接返回，不逆转</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; k) <span class="keyword">return</span> head;</span><br><span class="line">    head2 = head-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> next = head2-&gt;next;</span><br><span class="line">        head2-&gt;next = head;</span><br><span class="line">        head = head2;</span><br><span class="line">        head2 = next;</span><br><span class="line">    }</span><br><span class="line">    tail-&gt;next = <span class="built_in">reverseKGroup</span>(head2, k);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 牛客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表内指定区间反转</title>
      <link href="/2022/05/30/%E9%93%BE%E8%A1%A8%E5%86%85%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E5%8F%8D%E8%BD%AC/"/>
      <url>/2022/05/30/%E9%93%BE%E8%A1%A8%E5%86%85%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="链表内指定区间反转"><a href="#链表内指定区间反转" class="headerlink" title="链表内指定区间反转"></a>链表内指定区间反转</h1><ul><li><a href="https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=295&amp;tqId=654&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=/exam/oj">题目链接</a></li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)<em>O</em>(<em>n</em>)，空间复杂度 O(1)<em>O</em>(1)。<br>例如：<br>给出的链表为 1\to 2 \to 3 \to 4 \to 5 \to NULL1→2→3→4→5→<em>N<strong>U</strong>L**L</em>, m=2,n=4<em>m</em>=2,<em>n</em>=4,<br>返回 1\to 4\to 3\to 2\to 5\to NULL1→4→3→2→5→<em>N<strong>U</strong>L**L</em>.</p><p>数据范围： 链表长度 0 &lt; size \le 10000&lt;<em>s<strong>i</strong>z**e</em>≤1000，0 &lt; m \le n \le size0&lt;<em>m</em>≤<em>n</em>≤<em>s<strong>i</strong>z**e</em>，链表中每个节点的值满足 |val| \le 1000∣<em>v<strong>a</strong>l</em>∣≤1000</p><p>要求：时间复杂度 O(n)<em>O</em>(<em>n</em>) ，空间复杂度 O(n)<em>O</em>(<em>n</em>)</p><p>进阶：时间复杂度 O(n)<em>O</em>(<em>n</em>)，空间复杂度 O(1)<em>O</em>(1)</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{1,2,3,4,5},2,4</span><br></pre></td></tr></tbody></table></figure><p>复制</p><p>返回值：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{1,4,3,2,5}</span><br></pre></td></tr></tbody></table></figure><p>复制</p><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{5},1,1</span><br></pre></td></tr></tbody></table></figure><p>复制</p><p>返回值：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{5}</span><br></pre></td></tr></tbody></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><p>首先先写一个链表反转的代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseLinkedList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">auto</span> head2 = head-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (head2)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> next = head2-&gt;next;</span><br><span class="line">        head2-&gt;next = head;</span><br><span class="line">        head = head2;</span><br><span class="line">        head2 = next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>去 <a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=295&amp;tqId=23286&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=/exam/oj">这里</a> 测试代码</li></ul></li><li><p>要想逆转区间内的链表，首先要写一个逆转前k个节点的函数 <code>ReversePreKNode</code>, 并返回逆转后的头节点</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reversePreKNodes</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 首先计算该链表的长度len</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode* head2 = head, *tail = head;</span><br><span class="line">    <span class="keyword">while</span> (head2) {head2=head2-&gt;next; len++;}</span><br><span class="line">    <span class="comment">// 长度不足k个节点，直接返回，不逆转</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; k) <span class="keyword">return</span> head;</span><br><span class="line">    head2 = head-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> next = head2-&gt;next;</span><br><span class="line">        head2-&gt;next = head;</span><br><span class="line">        head = head2;</span><br><span class="line">        head2 = next;</span><br><span class="line">    }</span><br><span class="line">    tail-&gt;next = head2;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>接下来只要找到链表的第 <code>m-1</code> 个节点可以了，完整代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="type">int</span> k = n - m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>)    <span class="keyword">return</span> <span class="built_in">reversePreKNodes</span>(head, k);</span><br><span class="line">    ListNode* head2 = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m<span class="number">-1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        head2 = head2-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    head2-&gt;next = <span class="built_in">reversePreKNodes</span>(head2-&gt;next, k);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reversePreKNodes</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 首先计算该链表的长度len</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode* head2 = head, *tail = head;</span><br><span class="line">    <span class="keyword">while</span> (head2) {head2=head2-&gt;next; len++;}</span><br><span class="line">    <span class="comment">// 长度不足k个节点，直接返回，不逆转</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; k) <span class="keyword">return</span> head;</span><br><span class="line">    head2 = head-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> next = head2-&gt;next;</span><br><span class="line">        head2-&gt;next = head;</span><br><span class="line">        head = head2;</span><br><span class="line">        head2 = next;</span><br><span class="line">    }</span><br><span class="line">    tail-&gt;next = head2;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>做这些链表的题目时，其实不难，思路是正确的，但是很少能一下子pass，总是要依靠多次debug才能完整pass，我觉得解题目时分步骤coding可以大大改善这种困境。例如以上反转区间的问题，先把它分为两步：<ol><li>逆转链表的前K个节点</li><li>找到第 <code>m-1</code> 个节点</li></ol></li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><ul><li><a href="/2022/05/30/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%AF%8Fk%E4%B8%AA%E7%BF%BB%E8%BD%AC">链表中的节点每k个一组翻转</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 牛客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dos命令copy与xcopy</title>
      <link href="/2022/05/29/dos%E5%91%BD%E4%BB%A4copy%E4%B8%8Excopy/"/>
      <url>/2022/05/29/dos%E5%91%BD%E4%BB%A4copy%E4%B8%8Excopy/</url>
      
        <content type="html"><![CDATA[<h1 id="Dos命令-copy-与-xcopy"><a href="#Dos命令-copy-与-xcopy" class="headerlink" title="Dos命令 copy 与 xcopy"></a>Dos命令 copy 与 xcopy</h1><h2 id="为什么要用这两个命令"><a href="#为什么要用这两个命令" class="headerlink" title="为什么要用这两个命令"></a>为什么要用这两个命令</h2><ul><li>windows管理器中 <code>Ctrl+C</code> 然后 <code>Ctrl+V</code> 就行了，为什么还要学这两个命令？</li><li>说一个我平常会用到 这两个命令的场景<ul><li>开发的一个客户端程序 <code>A</code> 会在运行时动态加载一个 <code>B.dll</code> 在开发 <code>B.dll</code> 的时候要时常将编译好的 dll 文件手动copy到客户端程序A的运行目录，为了减少手动复制，我会在 dll项目编译后自动执行一句脚本，将 <code>B.dll</code> 复制到 A程序的运行目录 (vs项目的 BuildEvents:Post-build event command line)</li></ul></li></ul><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><ul><li><p><a href="https://home.csulb.edu/~murdock/copy.html">copy</a><sup>1</sup>：用于copy文件</p></li><li><p>查看帮助: <code>copy /?</code></p><figure class="highlight dos"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">smx</span>&gt;<span class="title">copy</span> /?</span></span><br><span class="line"><span class="function">将一份或多份文件复制到另一个位置。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">COPY</span> [/<span class="title">D</span>] [/<span class="title">V</span>] [/<span class="title">N</span>] [/<span class="title">Y</span> | /-<span class="title">Y</span>] [/<span class="title">Z</span>] [/<span class="title">L</span>] [/<span class="title">A</span> | /<span class="title">B</span> ] <span class="title">source</span> [/<span class="title">A</span> | /<span class="title">B</span>]</span></span><br><span class="line"><span class="function">     [+ <span class="title">source</span> [/<span class="title">A</span> | /<span class="title">B</span>] [+ ...]] [<span class="title">destination</span> [/<span class="title">A</span> | /<span class="title">B</span>]]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">source</span>       指定要复制的文件。</span></span><br><span class="line"><span class="function">  /<span class="title">A</span>           表示一个 <span class="title">ASCII</span> 文本文件。</span></span><br><span class="line"><span class="function">  /<span class="title">B</span>           表示一个二进位文件。</span></span><br><span class="line"><span class="function">  /<span class="title">D</span>           允许解密要创建的目标文件</span></span><br><span class="line"><span class="function">  <span class="title">destination</span>  为新文件指定目录和/或文件名。</span></span><br><span class="line"><span class="function">  /<span class="title">V</span>           验证新文件写入是否正确。</span></span><br><span class="line"><span class="function">  /<span class="title">N</span>           复制带有非 8<span class="title">dot3</span> 名称的文件时，</span></span><br><span class="line"><span class="function">               尽可能使用短文件名。</span></span><br><span class="line"><span class="function">  /<span class="title">Y</span>           不使用确认是否要覆盖现有目标文件</span></span><br><span class="line"><span class="function">               的提示。</span></span><br><span class="line"><span class="function">  /-<span class="title">Y</span>          使用确认是否要覆盖现有目标文件</span></span><br><span class="line"><span class="function">               的提示。</span></span><br><span class="line"><span class="function">  /<span class="title">Z</span>           用可重新启动模式复制已联网的文件。</span></span><br><span class="line"><span class="function">/<span class="title">L</span>           如果源是符号链接，请将链接复制</span></span><br><span class="line"><span class="function">               到目标而不是源链接指向的实际文件。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">命令行开关 /<span class="title">Y</span> 可以在 <span class="title">COPYCMD</span> 环境变量中预先设定。</span></span><br><span class="line"><span class="function">这可能会被命令行上的 /-<span class="title">Y</span> 替代。除非 <span class="title">COPY</span></span></span><br><span class="line"><span class="function">命令是在一个批处理脚本中执行的，默认值应为</span></span><br><span class="line"><span class="function">在覆盖时进行提示。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">要附加文件，请为目标指定一个文件，为源指定</span></span><br><span class="line"><span class="function">数个文件(用通配符或 <span class="title">file1</span>+<span class="title">file2</span>+<span class="title">file3</span> 格式)。</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>常用的一些选项:</p><ul><li><code>/y</code>: 覆盖不提示</li></ul></li><li><p>samples:</p><ul><li><p>将文件<code>file1</code> 复制为 <code>file2</code>, <code>file2</code> 文件不存在： <code>copy file1 file2</code></p></li><li><p>将文件 <code>file1</code> 复制为 <code>file2</code>, <code>file2</code> 文件已经存在: </p><figure class="highlight dos"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">F:\<span class="title">files</span>\<span class="title">blend</span>\<span class="title">test</span>&gt;<span class="title">copy</span> <span class="title">file1</span> <span class="title">file2</span></span></span><br><span class="line"><span class="function">覆盖 <span class="title">file2</span> 吗? (<span class="title">Yes</span>/<span class="title">No</span>/<span class="title">All</span>): <span class="title">Yes</span></span></span><br><span class="line"><span class="function">已复制         1 个文件。</span></span><br><span class="line"><span class="function"><span class="title">F</span>:\<span class="title">files</span>\<span class="title">blend</span>\<span class="title">test</span>&gt;<span class="title">copy</span> /<span class="title">y</span> <span class="title">file1</span> <span class="title">file2</span></span></span><br><span class="line"><span class="function">已复制         1 个文件。</span></span><br></pre></td></tr></tbody></table></figure><ul><li>如果想要覆盖不提示 需要添加 <code>/y</code> 参数: <code>copy /y file1 file2</code></li></ul></li><li><p>将文件 <code>file1</code> 复制到 <code>folder1</code> 目录下: <code>copy file1 folder1</code></p></li><li><p>将文件 <code>file1</code> 复制到 <code>folder1</code>目录下并命名为 <code>file2</code>: <code>copy file1 "folder1/file2"</code></p><ul><li><font color="red"><strong>note:</strong></font> 这里的 <code>"folder1/file2"</code> 必须要加上引号才行</li></ul></li></ul></li></ul><h2 id="xcopy"><a href="#xcopy" class="headerlink" title="xcopy"></a>xcopy</h2><ul><li><p><a href="https://home.csulb.edu/~murdock/xcopy.html">xcopy</a><sup>2</sup>: 可以复制文件和目录</p></li><li><p>查看帮助: <code>xcopy /?</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">F:\files\blend\test&gt;xcopy /?</span><br><span class="line">复制文件和目录树。</span><br><span class="line"></span><br><span class="line">XCOPY source [destination] [/A | /M] [/D[:date]] [/P] [/S [/E]] [/V] [/W]</span><br><span class="line">                           [/C] [/I] [/Q] [/F] [/L] [/G] [/H] [/R] [/T] [/U]</span><br><span class="line">                           [/K] [/N] [/O] [/X] [/Y] [/-Y] [/Z] [/B] [/J]</span><br><span class="line">                           [/EXCLUDE:file1[+file2][+file3]...] [/COMPRESS]</span><br><span class="line"></span><br><span class="line">  source       指定要复制的文件。</span><br><span class="line">  destination  指定新文件的位置和/或名称。</span><br><span class="line">  /A           仅复制有存档属性集的文件，</span><br><span class="line">               但不更改属性。</span><br><span class="line">  /M           仅复制有存档属性集的文件，</span><br><span class="line">               并关闭存档属性。</span><br><span class="line">  /D:m-d-y     复制在指定日期或指定日期以后更改的文件。</span><br><span class="line">               如果没有提供日期，则只复制</span><br><span class="line">               源时间比目标时间新的文件。</span><br><span class="line">  /EXCLUDE:file1[+file2][+file3]...</span><br><span class="line">               指定含有字符串的文件列表。每个字符串</span><br><span class="line">               在文件中应位于单独的一行。如果任何</span><br><span class="line">               字符串与复制文件的绝对路径的任何部分相符，</span><br><span class="line">               则排除复制该文件。例如，</span><br><span class="line">               指定如 \obj\ 或 .obj 的字符串会分别</span><br><span class="line">               排除目录 obj 下面的所有文件或带有</span><br><span class="line">               .obj 扩展名的所有文件。</span><br><span class="line">  /P           创建每个目标文件之前均进行提示。</span><br><span class="line">  /S           复制目录和子目录，不包括空目录。</span><br><span class="line">  /E           复制目录和子目录，包括空目录。</span><br><span class="line">               与 /S /E 相同。可以用来修改 /T。</span><br><span class="line">  /V           验证每个新文件的大小。</span><br><span class="line">  /W           提示在复制前按键。</span><br><span class="line">  /C           即使有错误，也继续复制。</span><br><span class="line">  /I           如果目标不存在，且要复制多个文件，</span><br><span class="line">               则假定目标必须是目录。</span><br><span class="line">  /Q           复制时不显示文件名。</span><br><span class="line">  /F           复制时显示完整的源文件名和目标文件名。</span><br><span class="line">  /L           显示要复制的文件。</span><br><span class="line">  /G           允许将加密文件复制到</span><br><span class="line">               不支持加密的目标。</span><br><span class="line">  /H           隐藏文件和系统文件也会复制。</span><br><span class="line">  /R           覆盖只读文件。</span><br><span class="line">  /T           创建目录结构，但不复制文件。不</span><br><span class="line">               包括空目录或子目录。/T /E 包括</span><br><span class="line">               空目录和子目录。</span><br><span class="line">  /U           只复制已经存在于目标中的文件。</span><br><span class="line">  /K           复制属性。一般的 Xcopy 会重置只读属性。</span><br><span class="line">  /N           用生成的短名称复制。</span><br><span class="line">  /O           复制文件所有权和 ACL 信息。</span><br><span class="line">  /X           复制文件审核设置(隐含 /O)。</span><br><span class="line">  /Y           取消提示以确认要覆盖</span><br><span class="line">               现有目标文件。</span><br><span class="line">  /-Y          触发提示，以确认要覆盖</span><br><span class="line">               现有目标文件。</span><br><span class="line">  /Z           在可重新启动模式下复制网络文件。</span><br><span class="line">  /B           复制符号链接本身与链接目标。</span><br><span class="line">  /J           复制时不使用缓冲的 I/O。推荐复制大文件时使用。</span><br><span class="line">  /COMPRESS    如果适用，在传输期间请求网络</span><br><span class="line">               压缩。</span><br><span class="line"></span><br><span class="line">开关 /Y 可以预先在 COPYCMD 环境变量中设置。</span><br><span class="line">这可能被命令行上的 /-Y 覆盖。</span><br></pre></td></tr></tbody></table></figure></li><li><p>常用的一些选项: <code>/iqyes</code></p><ul><li><p><code>/y</code>：覆盖不提示，否则</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F:\files\blend\practices\copy&gt;xcopy /iqs test test1</span><br><span class="line">覆盖 F:\files\blend\practices\copy\test1\1.txt (Y:是/N:否/A:全部)?</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>/Q</code>:  复制的时候不显示文件名，否则</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F:\files\blend\practices\copy&gt;xcopy /isy test test1</span><br><span class="line">test\1.txt</span><br><span class="line">test\2.txt</span><br><span class="line">test\3.txt</span><br><span class="line">test\4.txt</span><br><span class="line">test\subfolder\sub.txt</span><br><span class="line">复制了 5 个文件</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>/I</code>:  如果目标不存在，且要复制多个文件，则假定目标是目录</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F:\files\blend\practices\copy&gt;xcopy /qs test test2</span><br><span class="line">目标 test2 是文件名</span><br><span class="line">还是目录名</span><br><span class="line">(F = 文件，D = 目录)?</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>/E</code>:  复制目录和子目录（包括空目录）</p></li><li><p><code>/S</code>:  复制目标和子目录（不包括空目录）</p></li></ul></li><li><p>samples</p><ul><li><p>将文件 <code>file1</code> 复制为 <code>file2</code> , <code>file2</code>不存在:</p><figure class="highlight dos"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">F:\<span class="title">files</span>\<span class="title">blend</span>\<span class="title">test</span>&gt;<span class="title">xcopy</span> <span class="title">file1</span> <span class="title">file2</span></span></span><br><span class="line"><span class="function">目标 <span class="title">file2</span> 是文件名</span></span><br><span class="line"><span class="function">还是目录名</span></span><br><span class="line"><span class="function">(<span class="title">F</span> = 文件，<span class="title">D</span> = 目录)? <span class="title">F</span></span></span><br><span class="line"><span class="function"><span class="title">F:file1</span></span></span><br><span class="line"><span class="function">复制了 1 个文件</span></span><br></pre></td></tr></tbody></table></figure><ul><li>因为不确定目标是文件还是目录，所以这里会提示你是文件还是目录</li></ul></li><li><p>将文件 <code>file1</code> 复制为 <code>file2</code>, <code>file2</code>文件已存在: <code>xcopy /y file1 file2</code> 这里不会提示文件还是目录，因为 <code>file2</code>文件已存在，确认是文件</p></li><li><p>将文件 <code>file1</code> 复制到 <code>folder1</code>目录下 <code>folder1</code>目录已存在：<code>xcopy /y file1 folder1</code></p></li><li><p>将文件 <code>file1</code> 复制到 <code>fodler1</code> 目录下，<code>folder1 </code>目录不存在: </p><figure class="highlight dos"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">F:\<span class="title">files</span>\<span class="title">blend</span>\<span class="title">test</span>&gt;<span class="title">xcopy</span> <span class="title">file1</span> <span class="title">folder1</span></span></span><br><span class="line"><span class="function">目标 <span class="title">folder1</span> 是文件名</span></span><br><span class="line"><span class="function">还是目录名</span></span><br><span class="line"><span class="function">(<span class="title">F</span> = 文件，<span class="title">D</span> = 目录)? <span class="title">D</span></span></span><br><span class="line"><span class="function"><span class="title">F:file1</span></span></span><br><span class="line"><span class="function">复制了 1 个文件</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>将目录 <code>folder1</code> 复制为 <code>folder2</code>目录 <code>folder2</code>目录不存在: <code>xcopy /i folder1 folder2 </code></p></li><li><p>将目录 <code>folder1</code> 复制为 <code>folder2</code>目录 <code>folder2</code>目录存在: <code>xcopy /y folder1 folder2 </code></p></li><li><p>将目录 <code>folder1</code> 复制到 <code>folder2</code> 目录下并命名为 <code>test</code> 目录 : <code>xcopy /i folder1 "folder2/test"</code></p></li><li><p>将目录 <code>folder1</code> 所有内容复制到 <code>folder2/test</code>目录下， <code>folder2/test</code> 目录存在: <code>xcopy /y /q folder1 "folder2/test"</code></p></li></ul></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><p><code>[1]</code> <a href="https://home.csulb.edu/~murdock/copy.html">copy</a></p></li><li><p><code>[2]</code> <a href="https://home.csulb.edu/~murdock/xcopy.html">xcopy</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> dos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dos </tag>
            
            <tag> commands </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c程序定位段错误segment fault</title>
      <link href="/2022/05/28/c%E7%A8%8B%E5%BA%8F%E5%AE%9A%E4%BD%8D%E6%AE%B5%E9%94%99%E8%AF%AFsegment-fault/"/>
      <url>/2022/05/28/c%E7%A8%8B%E5%BA%8F%E5%AE%9A%E4%BD%8D%E6%AE%B5%E9%94%99%E8%AF%AFsegment-fault/</url>
      
        <content type="html"><![CDATA[<h1 id="c程序定位段错误segment-fault"><a href="#c程序定位段错误segment-fault" class="headerlink" title="c程序定位段错误segment fault"></a>c程序定位段错误segment fault</h1><ul><li>在编写c语言程序时，会经常不小心写出 段错误 的bug代码，但是又不知道导致段错误的代码，有小伙伴会说，可以gdb一行一行地调试啊，虽然这样是可以的，但是效率太低，接下来我会演示一下如何定位段错误的位置</li></ul><h2 id="首先要了解段错误"><a href="#首先要了解段错误" class="headerlink" title="首先要了解段错误"></a>首先要了解段错误</h2><h3 id="导致段错误的原因"><a href="#导致段错误的原因" class="headerlink" title="导致段错误的原因"></a>导致段错误的原因</h3><ul><li>一般有四种原因<ol><li>访问了非法内存: <code>int* p = NULL; printf("%d\n", *p);</code></li><li>数组越界: <code>int a[4]; a[4] = 1;</code> 数组越界存在不确定因素，有时候会出现段错误，有时候不会</li><li>scanf错误使用: <code>int a; scanf("%d", a);</code></li><li>指针访问只读内存： <code>char* str = "111"; str[0] = 'a';</code></li></ol></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul><li><p>编写代码：<code>segment.c</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    *p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>编译并运行:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos c]<span class="comment"># gcc -g segment.c</span></span><br><span class="line">[root@VM-16-5-centos c]<span class="comment"># ./a.out</span></span><br><span class="line">Segmentation fault</span><br><span class="line">[root@VM-16-5-centos c]<span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>如上所示，执行程序的时候，报段错误，但是没有生成 <code>core</code> 文件，所以需要手动设置一下 <a href="https://www.linuxcool.com/ulimit">ulimit</a><sup>1</sup> 然后再运行，并查看生成的core文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos c]<span class="comment"># ulimit -c unlimited</span></span><br><span class="line">[root@VM-16-5-centos c]<span class="comment"># ./a.out</span></span><br><span class="line">Segmentation fault (core dumped)</span><br><span class="line">[root@VM-16-5-centos c]<span class="comment"># ls</span></span><br><span class="line">a.out  core.26602  error.txt  pipe.c  read_pipe.c  segment.c  simulate_commands  write_pipe.c</span><br></pre></td></tr></tbody></table></figure></li><li><p>如上图所示中的 <code>core.26602</code> 就是生成的段错误文件，接下来我们要进入gdb来分析该 core文件定位导致段错误的位置</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos c]<span class="comment"># gdb a.out core.26602</span></span><br><span class="line">GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-120.el7</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-redhat-linux-gnu"</span>.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</span><br><span class="line">Reading symbols from /root/files/blend/gitpros/linux/coding/c/a.out...done.</span><br><span class="line">[New LWP 27251]</span><br><span class="line">Core was generated by `./a.out<span class="string">'.</span></span><br><span class="line"><span class="string">Program terminated with signal 11, Segmentation fault.</span></span><br><span class="line"><span class="string">#0  0x00000000004004fd in main () at segment.c:6</span></span><br><span class="line"><span class="string">6*p = 1;</span></span><br><span class="line"><span class="string">Missing separate debuginfos, use: debuginfo-install glibc-2.17-325.el7_9.x86_64</span></span><br><span class="line"><span class="string">(gdb) </span></span><br></pre></td></tr></tbody></table></figure></li><li><p>从以上的gdb信息就可以看到导致段错误的代码位置: </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Program terminated with signal 11, Segmentation fault.</span><br><span class="line"><span class="comment">#0  0x00000000004004fd in main () at segment.c:6</span></span><br><span class="line">6*p = 1;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><code>[1]</code> <a href="https://www.linuxcool.com/ulimit">ulimit</a></li></ul><h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h2><ul><li><code>ulimit</code></li><li><code>gdb a.out core</code></li><li><code>gcc -g segment.c</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> linux </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现linux的cat命令</title>
      <link href="/2022/05/27/%E5%AE%9E%E7%8E%B0linux%E7%9A%84cat%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/05/27/%E5%AE%9E%E7%8E%B0linux%E7%9A%84cat%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="实现linux的cat命令"><a href="#实现linux的cat命令" class="headerlink" title="实现linux的cat命令"></a>实现linux的cat命令</h1><h2 id="cat命令简介"><a href="#cat命令简介" class="headerlink" title="cat命令简介"></a>cat命令简介</h2><ul><li>首先linux的命令手册: <code>man cat</code>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat - concatenate files and print on the standard output</span><br></pre></td></tr></tbody></table></figure></li><li><a href="https://www.linuxcool.com/cat">cat</a><sup>1</sup>: 在终端设备上显示文件内容，其功能是用于查看文件内容</li></ul><h2 id="C代码实现"><a href="#C代码实现" class="headerlink" title="C代码实现"></a>C代码实现</h2><ul><li><p>首先看几个函数</p><ul><li><a href="https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm">fopen</a><sup>2</sup>: The C library function <code>FILE *fopen(const char *filename, const char *mode)</code> opens the filename pointed to, by filename using the given mode.<ul><li>打开文件，返回文件指针</li><li>example: <code>FILE* fp = fopen("test.txt", "r");</code></li></ul></li><li><a href="https://www.tutorialspoint.com/c_standard_library/c_function_fread.htm">fread</a><sup>3</sup>: The C library function size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) reads data from the given stream into the array pointed to, by ptr.<ul><li>从文件中读取字节</li><li>example: <code>int len = fread(buffer, 1, 5, fp);</code></li></ul></li><li><a href="https://www.tutorialspoint.com/c_standard_library/c_function_fprintf.htm">fprintf</a><sup>4</sup>: The C library function int fprintf(FILE *stream, const char *format, …) sends formatted output to a stream.<ul><li>格式化输出到流</li><li>examples:<ul><li>格式化输出到标准输出流: <code>fprintf(stdout, "this is standard output!\n")</code>, 相当于 <code>printf</code></li><li>格式化输出到标准错误流: <code>fprintf(stderr, "this is standard error!\n")</code></li></ul></li></ul></li><li><a href="https://www.tutorialspoint.com/c_standard_library/c_function_fclose.htm">fclose</a><sup>5</sup>: The C library function int fclose(FILE *stream) closes the stream. All buffers are flushed.<ul><li>关闭文件流</li><li>example: <code>fclose(fp)</code></li></ul></li><li><a href="https://linux.die.net/man/2/access">access</a><sup>6</sup>: access - check real user’s permissions for a file<ul><li>判断是否具有文件操作的权限</li><li>examples:<ul><li>判断文件是否存在: <code>if (access(file_path, F_OK) == 0){}</code></li><li>判断是否可以读取文件: <code>if (access(file_path, R_OK) == 0){}</code></li><li>判断是否可以写入文件: <code>if (access(file_path, W_OK) == 0){}</code></li></ul></li></ul></li><li><a href="https://man7.org/linux/man-pages/man3/getline.3.html">getline</a><sup>7</sup>: reads an entire line from stream,<ul><li>从流中读取一整行</li><li>example: <code>ssize_t read = getline(&amp;buffer, &amp;len, stdin);</code></li></ul></li></ul></li><li><p>创建 <code>mycat.c</code></p></li><li><p><code>cat</code> 命令需要接文件参数，引入参数</p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>{<span class="keyword">return</span> <span class="number">0</span>;}</span><br></pre></td></tr></tbody></table></figure></li><li><p>判断参数的个数，如果小于等于1个参数需要按行输出用户的输入</p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// take user's input and output it by line</span></span><br><span class="line"><span class="type">char</span>* line;</span><br><span class="line"><span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="type">ssize_t</span> read;</span><br><span class="line"><span class="keyword">while</span> ((read = getline(&amp;line, &amp;len, <span class="built_in">stdin</span>) != <span class="number">-1</span>))</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, line);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (line)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">free</span>(line);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>定义一个专门显示文件内容的函数</p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">show_file_content</span><span class="params">(<span class="type">char</span>* file_path)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (access(file_path, R_OK) == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        FILE* fp = fopen(file_path, <span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">char</span> buffer[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (len = fread(buffer, <span class="number">1</span>, <span class="number">4</span>, fp))</span><br><span class="line">            {</span><br><span class="line">                buffer[len] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, buffer);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"file open error\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"mycat: 1: No such file or directory\n"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>接下来是main函数的调用:</p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">        {</span><br><span class="line">            show_file_content(argv[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// take user's input and output it</span></span><br><span class="line">        <span class="type">char</span>* line;</span><br><span class="line">        <span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ssize_t</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = getline(&amp;line, &amp;len, <span class="built_in">stdin</span>) != <span class="number">-1</span>))</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s"</span>, line);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (line)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">free</span>(line);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>全部代码: <code>mycat.c</code></p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_file_content</span><span class="params">(<span class="type">char</span>* file_path)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (access(file_path, R_OK) == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        FILE* fp = fopen(file_path, <span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">char</span> buffer[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (len = fread(buffer, <span class="number">1</span>, <span class="number">4</span>, fp))</span><br><span class="line">            {</span><br><span class="line">                buffer[len] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, buffer);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"file open error\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"mycat: 1: No such file or directory\n"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">        {</span><br><span class="line">            show_file_content(argv[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// take user's input and output it</span></span><br><span class="line">        <span class="type">char</span>* line;</span><br><span class="line">        <span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ssize_t</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = getline(&amp;line, &amp;len, <span class="built_in">stdin</span>) != <span class="number">-1</span>))</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s"</span>, line);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (line)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">free</span>(line);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ul><li>先编译: <code>gcc mycat.c -o mycat</code></li><li>无参数运行: <code>./mycat</code> <code>Ctrl + D</code> 结束输入  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos simulate_commands]# ./mycat</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">my name is smx</span><br><span class="line">my name is smx</span><br><span class="line">how are you today</span><br><span class="line">how are you today</span><br><span class="line">bye</span><br><span class="line">bye</span><br></pre></td></tr></tbody></table></figure></li><li>带参数运行: <code>./mycat 1.txt 2.txt</code></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><code>[1]</code> <a href="https://www.linuxcool.com/cat">cat命令详细介绍</a></li><li><code>[2]</code> <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm">fopen c函数</a></li><li><code>[3]</code> <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fread.htm">fread c函数</a></li><li><code>[4]</code> <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fprintf.htm">fprintf c函数</a></li><li><code>[5]</code> <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fclose.htm">fclose c函数</a></li><li><code>[6]</code> <a href="https://linux.die.net/man/2/access">access c函数</a></li><li><code>[7]</code> <a href="https://man7.org/linux/man-pages/man3/getline.3.html">getline c函数</a></li></ul><h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h2><ul><li>c函数<ul><li><code>fopen</code>、<code>fread</code>、<code>fprintf</code>、<code>fclose</code>、<code>access</code>、 <code>getline</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
