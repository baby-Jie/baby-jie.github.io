<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>链表中的节点每k个翻转</title>
      <link href="/2022/05/30/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%AF%8Fk%E4%B8%AA%E7%BF%BB%E8%BD%AC/"/>
      <url>/2022/05/30/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%AF%8Fk%E4%B8%AA%E7%BF%BB%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="链表中的节点每k个一组翻转"><a href="#链表中的节点每k个一组翻转" class="headerlink" title="链表中的节点每k个一组翻转"></a><strong>链表中的节点每k个一组翻转</strong></h1><ul><li><a href="https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=295&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=/exam/oj">题目链接</a></li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样<br>你不能更改节点中的值，只能更改节点本身。</p><p>数据范围： \ 0 \le n \le 2000 0≤<em>n</em>≤2000 ， 1 \le k \le 20001≤<em>k</em>≤2000 ，链表中每个元素都满足 0 \le val \le 10000≤<em>v<strong>a</strong>l</em>≤1000<br>要求空间复杂度 O(1)<em>O</em>(1)，时间复杂度 O(n)<em>O</em>(<em>n</em>)</p><p>例如：</p><p>给定的链表是 1\to2\to3\to4\to51→2→3→4→5</p><p>对于 k = 2<em>k</em>=2 , 你应该返回 2\to 1\to 4\to 3\to 52→1→4→3→5</p><p>对于 k = 3<em>k</em>=3 , 你应该返回 3\to2 \to1 \to 4\to 53→2→1→4→5</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{1,2,3,4,5},2</span><br></pre></td></tr></tbody></table></figure><p>复制</p><p>返回值：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{2,1,4,3,5}</span><br></pre></td></tr></tbody></table></figure><p>复制</p><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{},1</span><br></pre></td></tr></tbody></table></figure><p>复制</p><p>返回值：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{}</span><br></pre></td></tr></tbody></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li><p>和 <strong>链表内指定区间反转</strong> 一样，首先写一个函数，反转链表前k个节点</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 首先计算该链表的长度len</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode* head2 = head, *tail = head;</span><br><span class="line">    <span class="keyword">while</span> (head2) {head2=head2-&gt;next; len++;}</span><br><span class="line">    <span class="comment">// 长度不足k个节点，直接返回，不逆转</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; k) <span class="keyword">return</span> head;</span><br><span class="line">    head2 = head-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> next = head2-&gt;next;</span><br><span class="line">        head2-&gt;next = head;</span><br><span class="line">        head = head2;</span><br><span class="line">        head2 = next;</span><br><span class="line">    }</span><br><span class="line">    tail-&gt;next = head2;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>接下来的操作很简单，只需要在函数返回前 对剩下来的节点再进行 反转前k个节点 操作即可</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail-&gt;next = <span class="built_in">reverseKGroup</span>(head2, k);</span><br></pre></td></tr></tbody></table></figure></li><li><p>完整代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 首先计算该链表的长度len</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode* head2 = head, *tail = head;</span><br><span class="line">    <span class="keyword">while</span> (head2) {head2=head2-&gt;next; len++;}</span><br><span class="line">    <span class="comment">// 长度不足k个节点，直接返回，不逆转</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; k) <span class="keyword">return</span> head;</span><br><span class="line">    head2 = head-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> next = head2-&gt;next;</span><br><span class="line">        head2-&gt;next = head;</span><br><span class="line">        head = head2;</span><br><span class="line">        head2 = next;</span><br><span class="line">    }</span><br><span class="line">    tail-&gt;next = <span class="built_in">reverseKGroup</span>(head2, k);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 牛客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表内指定区间反转</title>
      <link href="/2022/05/30/%E9%93%BE%E8%A1%A8%E5%86%85%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E5%8F%8D%E8%BD%AC/"/>
      <url>/2022/05/30/%E9%93%BE%E8%A1%A8%E5%86%85%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="链表内指定区间反转"><a href="#链表内指定区间反转" class="headerlink" title="链表内指定区间反转"></a>链表内指定区间反转</h1><ul><li><a href="https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=295&amp;tqId=654&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=/exam/oj">题目链接</a></li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)<em>O</em>(<em>n</em>)，空间复杂度 O(1)<em>O</em>(1)。<br>例如：<br>给出的链表为 1\to 2 \to 3 \to 4 \to 5 \to NULL1→2→3→4→5→<em>N<strong>U</strong>L**L</em>, m=2,n=4<em>m</em>=2,<em>n</em>=4,<br>返回 1\to 4\to 3\to 2\to 5\to NULL1→4→3→2→5→<em>N<strong>U</strong>L**L</em>.</p><p>数据范围： 链表长度 0 &lt; size \le 10000&lt;<em>s<strong>i</strong>z**e</em>≤1000，0 &lt; m \le n \le size0&lt;<em>m</em>≤<em>n</em>≤<em>s<strong>i</strong>z**e</em>，链表中每个节点的值满足 |val| \le 1000∣<em>v<strong>a</strong>l</em>∣≤1000</p><p>要求：时间复杂度 O(n)<em>O</em>(<em>n</em>) ，空间复杂度 O(n)<em>O</em>(<em>n</em>)</p><p>进阶：时间复杂度 O(n)<em>O</em>(<em>n</em>)，空间复杂度 O(1)<em>O</em>(1)</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{1,2,3,4,5},2,4</span><br></pre></td></tr></tbody></table></figure><p>复制</p><p>返回值：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{1,4,3,2,5}</span><br></pre></td></tr></tbody></table></figure><p>复制</p><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{5},1,1</span><br></pre></td></tr></tbody></table></figure><p>复制</p><p>返回值：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{5}</span><br></pre></td></tr></tbody></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><p>首先先写一个链表反转的代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseLinkedList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">auto</span> head2 = head-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (head2)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> next = head2-&gt;next;</span><br><span class="line">        head2-&gt;next = head;</span><br><span class="line">        head = head2;</span><br><span class="line">        head2 = next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>去 <a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=295&amp;tqId=23286&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=/exam/oj">这里</a> 测试代码</li></ul></li><li><p>要想逆转区间内的链表，首先要写一个逆转前k个节点的函数 <code>ReversePreKNode</code>, 并返回逆转后的头节点</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reversePreKNodes</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 首先计算该链表的长度len</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode* head2 = head, *tail = head;</span><br><span class="line">    <span class="keyword">while</span> (head2) {head2=head2-&gt;next; len++;}</span><br><span class="line">    <span class="comment">// 长度不足k个节点，直接返回，不逆转</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; k) <span class="keyword">return</span> head;</span><br><span class="line">    head2 = head-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> next = head2-&gt;next;</span><br><span class="line">        head2-&gt;next = head;</span><br><span class="line">        head = head2;</span><br><span class="line">        head2 = next;</span><br><span class="line">    }</span><br><span class="line">    tail-&gt;next = head2;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>接下来只要找到链表的第 <code>m-1</code> 个节点可以了，完整代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="type">int</span> k = n - m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>)    <span class="keyword">return</span> <span class="built_in">reversePreKNodes</span>(head, k);</span><br><span class="line">    ListNode* head2 = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m<span class="number">-1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        head2 = head2-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    head2-&gt;next = <span class="built_in">reversePreKNodes</span>(head2-&gt;next, k);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reversePreKNodes</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 首先计算该链表的长度len</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode* head2 = head, *tail = head;</span><br><span class="line">    <span class="keyword">while</span> (head2) {head2=head2-&gt;next; len++;}</span><br><span class="line">    <span class="comment">// 长度不足k个节点，直接返回，不逆转</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; k) <span class="keyword">return</span> head;</span><br><span class="line">    head2 = head-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> next = head2-&gt;next;</span><br><span class="line">        head2-&gt;next = head;</span><br><span class="line">        head = head2;</span><br><span class="line">        head2 = next;</span><br><span class="line">    }</span><br><span class="line">    tail-&gt;next = head2;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>做这些链表的题目时，其实不难，思路是正确的，但是很少能一下子pass，总是要依靠多次debug才能完整pass，我觉得解题目时分步骤coding可以大大改善这种困境。例如以上反转区间的问题，先把它分为两步：<ol><li>逆转链表的前K个节点</li><li>找到第 <code>m-1</code> 个节点</li></ol></li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><form action="/2022/05/30/链表中的节点每k个翻转" method="Get"><input type="submit" value="链表中的节点每k个一组翻转"></form>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 牛客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dos命令copy与xcopy</title>
      <link href="/2022/05/29/dos%E5%91%BD%E4%BB%A4copy%E4%B8%8Excopy/"/>
      <url>/2022/05/29/dos%E5%91%BD%E4%BB%A4copy%E4%B8%8Excopy/</url>
      
        <content type="html"><![CDATA[<h1 id="Dos命令-copy-与-xcopy"><a href="#Dos命令-copy-与-xcopy" class="headerlink" title="Dos命令 copy 与 xcopy"></a>Dos命令 copy 与 xcopy</h1><h2 id="为什么要用这两个命令"><a href="#为什么要用这两个命令" class="headerlink" title="为什么要用这两个命令"></a>为什么要用这两个命令</h2><ul><li>windows管理器中 <code>Ctrl+C</code> 然后 <code>Ctrl+V</code> 就行了，为什么还要学这两个命令？</li><li>说一个我平常会用到 这两个命令的场景<ul><li>开发的一个客户端程序 <code>A</code> 会在运行时动态加载一个 <code>B.dll</code> 在开发 <code>B.dll</code> 的时候要时常将编译好的 dll 文件手动copy到客户端程序A的运行目录，为了减少手动复制，我会在 dll项目编译后自动执行一句脚本，将 <code>B.dll</code> 复制到 A程序的运行目录 (vs项目的 BuildEvents:Post-build event command line)</li></ul></li></ul><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><ul><li><p><a href="https://home.csulb.edu/~murdock/copy.html">copy</a><sup>1</sup>：用于copy文件</p></li><li><p>查看帮助: <code>copy /?</code></p><figure class="highlight dos"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">smx</span>&gt;<span class="title">copy</span> /?</span></span><br><span class="line"><span class="function">将一份或多份文件复制到另一个位置。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">COPY</span> [/<span class="title">D</span>] [/<span class="title">V</span>] [/<span class="title">N</span>] [/<span class="title">Y</span> | /-<span class="title">Y</span>] [/<span class="title">Z</span>] [/<span class="title">L</span>] [/<span class="title">A</span> | /<span class="title">B</span> ] <span class="title">source</span> [/<span class="title">A</span> | /<span class="title">B</span>]</span></span><br><span class="line"><span class="function">     [+ <span class="title">source</span> [/<span class="title">A</span> | /<span class="title">B</span>] [+ ...]] [<span class="title">destination</span> [/<span class="title">A</span> | /<span class="title">B</span>]]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">source</span>       指定要复制的文件。</span></span><br><span class="line"><span class="function">  /<span class="title">A</span>           表示一个 <span class="title">ASCII</span> 文本文件。</span></span><br><span class="line"><span class="function">  /<span class="title">B</span>           表示一个二进位文件。</span></span><br><span class="line"><span class="function">  /<span class="title">D</span>           允许解密要创建的目标文件</span></span><br><span class="line"><span class="function">  <span class="title">destination</span>  为新文件指定目录和/或文件名。</span></span><br><span class="line"><span class="function">  /<span class="title">V</span>           验证新文件写入是否正确。</span></span><br><span class="line"><span class="function">  /<span class="title">N</span>           复制带有非 8<span class="title">dot3</span> 名称的文件时，</span></span><br><span class="line"><span class="function">               尽可能使用短文件名。</span></span><br><span class="line"><span class="function">  /<span class="title">Y</span>           不使用确认是否要覆盖现有目标文件</span></span><br><span class="line"><span class="function">               的提示。</span></span><br><span class="line"><span class="function">  /-<span class="title">Y</span>          使用确认是否要覆盖现有目标文件</span></span><br><span class="line"><span class="function">               的提示。</span></span><br><span class="line"><span class="function">  /<span class="title">Z</span>           用可重新启动模式复制已联网的文件。</span></span><br><span class="line"><span class="function">/<span class="title">L</span>           如果源是符号链接，请将链接复制</span></span><br><span class="line"><span class="function">               到目标而不是源链接指向的实际文件。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">命令行开关 /<span class="title">Y</span> 可以在 <span class="title">COPYCMD</span> 环境变量中预先设定。</span></span><br><span class="line"><span class="function">这可能会被命令行上的 /-<span class="title">Y</span> 替代。除非 <span class="title">COPY</span></span></span><br><span class="line"><span class="function">命令是在一个批处理脚本中执行的，默认值应为</span></span><br><span class="line"><span class="function">在覆盖时进行提示。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">要附加文件，请为目标指定一个文件，为源指定</span></span><br><span class="line"><span class="function">数个文件(用通配符或 <span class="title">file1</span>+<span class="title">file2</span>+<span class="title">file3</span> 格式)。</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>常用的一些选项:</p><ul><li><code>/y</code>: 覆盖不提示</li></ul></li><li><p>samples:</p><ul><li><p>将文件<code>file1</code> 复制为 <code>file2</code>, <code>file2</code> 文件不存在： <code>copy file1 file2</code></p></li><li><p>将文件 <code>file1</code> 复制为 <code>file2</code>, <code>file2</code> 文件已经存在: </p><figure class="highlight dos"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">F:\<span class="title">files</span>\<span class="title">blend</span>\<span class="title">test</span>&gt;<span class="title">copy</span> <span class="title">file1</span> <span class="title">file2</span></span></span><br><span class="line"><span class="function">覆盖 <span class="title">file2</span> 吗? (<span class="title">Yes</span>/<span class="title">No</span>/<span class="title">All</span>): <span class="title">Yes</span></span></span><br><span class="line"><span class="function">已复制         1 个文件。</span></span><br><span class="line"><span class="function"><span class="title">F</span>:\<span class="title">files</span>\<span class="title">blend</span>\<span class="title">test</span>&gt;<span class="title">copy</span> /<span class="title">y</span> <span class="title">file1</span> <span class="title">file2</span></span></span><br><span class="line"><span class="function">已复制         1 个文件。</span></span><br></pre></td></tr></tbody></table></figure><ul><li>如果想要覆盖不提示 需要添加 <code>/y</code> 参数: <code>copy /y file1 file2</code></li></ul></li><li><p>将文件 <code>file1</code> 复制到 <code>folder1</code> 目录下: <code>copy file1 folder1</code></p></li><li><p>将文件 <code>file1</code> 复制到 <code>folder1</code>目录下并命名为 <code>file2</code>: <code>copy file1 "folder1/file2"</code></p><ul><li><font color="red"><strong>note:</strong></font> 这里的 <code>"folder1/file2"</code> 必须要加上引号才行</li></ul></li></ul></li></ul><h2 id="xcopy"><a href="#xcopy" class="headerlink" title="xcopy"></a>xcopy</h2><ul><li><p><a href="https://home.csulb.edu/~murdock/xcopy.html">xcopy</a><sup>2</sup>: 可以复制文件和目录</p></li><li><p>查看帮助: <code>xcopy /?</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">F:\files\blend\test&gt;xcopy /?</span><br><span class="line">复制文件和目录树。</span><br><span class="line"></span><br><span class="line">XCOPY source [destination] [/A | /M] [/D[:date]] [/P] [/S [/E]] [/V] [/W]</span><br><span class="line">                           [/C] [/I] [/Q] [/F] [/L] [/G] [/H] [/R] [/T] [/U]</span><br><span class="line">                           [/K] [/N] [/O] [/X] [/Y] [/-Y] [/Z] [/B] [/J]</span><br><span class="line">                           [/EXCLUDE:file1[+file2][+file3]...] [/COMPRESS]</span><br><span class="line"></span><br><span class="line">  source       指定要复制的文件。</span><br><span class="line">  destination  指定新文件的位置和/或名称。</span><br><span class="line">  /A           仅复制有存档属性集的文件，</span><br><span class="line">               但不更改属性。</span><br><span class="line">  /M           仅复制有存档属性集的文件，</span><br><span class="line">               并关闭存档属性。</span><br><span class="line">  /D:m-d-y     复制在指定日期或指定日期以后更改的文件。</span><br><span class="line">               如果没有提供日期，则只复制</span><br><span class="line">               源时间比目标时间新的文件。</span><br><span class="line">  /EXCLUDE:file1[+file2][+file3]...</span><br><span class="line">               指定含有字符串的文件列表。每个字符串</span><br><span class="line">               在文件中应位于单独的一行。如果任何</span><br><span class="line">               字符串与复制文件的绝对路径的任何部分相符，</span><br><span class="line">               则排除复制该文件。例如，</span><br><span class="line">               指定如 \obj\ 或 .obj 的字符串会分别</span><br><span class="line">               排除目录 obj 下面的所有文件或带有</span><br><span class="line">               .obj 扩展名的所有文件。</span><br><span class="line">  /P           创建每个目标文件之前均进行提示。</span><br><span class="line">  /S           复制目录和子目录，不包括空目录。</span><br><span class="line">  /E           复制目录和子目录，包括空目录。</span><br><span class="line">               与 /S /E 相同。可以用来修改 /T。</span><br><span class="line">  /V           验证每个新文件的大小。</span><br><span class="line">  /W           提示在复制前按键。</span><br><span class="line">  /C           即使有错误，也继续复制。</span><br><span class="line">  /I           如果目标不存在，且要复制多个文件，</span><br><span class="line">               则假定目标必须是目录。</span><br><span class="line">  /Q           复制时不显示文件名。</span><br><span class="line">  /F           复制时显示完整的源文件名和目标文件名。</span><br><span class="line">  /L           显示要复制的文件。</span><br><span class="line">  /G           允许将加密文件复制到</span><br><span class="line">               不支持加密的目标。</span><br><span class="line">  /H           隐藏文件和系统文件也会复制。</span><br><span class="line">  /R           覆盖只读文件。</span><br><span class="line">  /T           创建目录结构，但不复制文件。不</span><br><span class="line">               包括空目录或子目录。/T /E 包括</span><br><span class="line">               空目录和子目录。</span><br><span class="line">  /U           只复制已经存在于目标中的文件。</span><br><span class="line">  /K           复制属性。一般的 Xcopy 会重置只读属性。</span><br><span class="line">  /N           用生成的短名称复制。</span><br><span class="line">  /O           复制文件所有权和 ACL 信息。</span><br><span class="line">  /X           复制文件审核设置(隐含 /O)。</span><br><span class="line">  /Y           取消提示以确认要覆盖</span><br><span class="line">               现有目标文件。</span><br><span class="line">  /-Y          触发提示，以确认要覆盖</span><br><span class="line">               现有目标文件。</span><br><span class="line">  /Z           在可重新启动模式下复制网络文件。</span><br><span class="line">  /B           复制符号链接本身与链接目标。</span><br><span class="line">  /J           复制时不使用缓冲的 I/O。推荐复制大文件时使用。</span><br><span class="line">  /COMPRESS    如果适用，在传输期间请求网络</span><br><span class="line">               压缩。</span><br><span class="line"></span><br><span class="line">开关 /Y 可以预先在 COPYCMD 环境变量中设置。</span><br><span class="line">这可能被命令行上的 /-Y 覆盖。</span><br></pre></td></tr></tbody></table></figure></li><li><p>常用的一些选项:</p><ul><li><code>/y</code>：覆盖不提示</li><li><code>/Q</code>:  复制的时候不显示文件名</li><li><code>/I</code>:  如果目标不存在，且要复制多个文件，则假定目标是目录</li><li><code>/E</code>:  复制目录和子目录（包括空目录）</li></ul></li><li><p>samples</p><ul><li><p>将文件 <code>file1</code> 复制为 <code>file2</code> , <code>file2</code>不存在:</p><figure class="highlight dos"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">F:\<span class="title">files</span>\<span class="title">blend</span>\<span class="title">test</span>&gt;<span class="title">xcopy</span> <span class="title">file1</span> <span class="title">file2</span></span></span><br><span class="line"><span class="function">目标 <span class="title">file2</span> 是文件名</span></span><br><span class="line"><span class="function">还是目录名</span></span><br><span class="line"><span class="function">(<span class="title">F</span> = 文件，<span class="title">D</span> = 目录)? <span class="title">F</span></span></span><br><span class="line"><span class="function"><span class="title">F:file1</span></span></span><br><span class="line"><span class="function">复制了 1 个文件</span></span><br></pre></td></tr></tbody></table></figure><ul><li>因为不确定目标是文件还是目录，所以这里会提示你是文件还是目录</li></ul></li><li><p>将文件 <code>file1</code> 复制为 <code>file2</code>, <code>file2</code>文件已存在: <code>xcopy /y file1 file2</code> 这里不会提示文件还是目录，因为 <code>file2</code>文件已存在，确认是文件</p></li><li><p>将文件 <code>file1</code> 复制到 <code>folder1</code>目录下 <code>folder1</code>目录已存在：<code>xcopy /y file1 folder1</code></p></li><li><p>将文件 <code>file1</code> 复制到 <code>fodler1</code> 目录下，<code>folder1 </code>目录不存在: </p><figure class="highlight dos"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">F:\<span class="title">files</span>\<span class="title">blend</span>\<span class="title">test</span>&gt;<span class="title">xcopy</span> <span class="title">file1</span> <span class="title">folder1</span></span></span><br><span class="line"><span class="function">目标 <span class="title">folder1</span> 是文件名</span></span><br><span class="line"><span class="function">还是目录名</span></span><br><span class="line"><span class="function">(<span class="title">F</span> = 文件，<span class="title">D</span> = 目录)? <span class="title">D</span></span></span><br><span class="line"><span class="function"><span class="title">F:file1</span></span></span><br><span class="line"><span class="function">复制了 1 个文件</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>将目录 <code>folder1</code> 复制为 <code>folder2</code>目录 <code>folder2</code>目录不存在: <code>xcopy /i folder1 folder2 </code></p></li><li><p>将目录 <code>folder1</code> 复制为 <code>folder2</code>目录 <code>folder2</code>目录存在: <code>xcopy /y folder1 folder2 </code></p></li><li><p>将目录 <code>folder1</code> 复制到 <code>folder2</code> 目录下并命名为 <code>test</code> 目录 : <code>xcopy /i folder1 "folder2/test"</code></p></li><li><p>将目录 <code>folder1</code> 所有内容复制到 <code>folder2/test</code>目录下， <code>folder2/test</code> 目录存在: ``xcopy /y /q folder1 “folder2/test”`</p></li></ul></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><p><code>[1]</code> <a href="https://home.csulb.edu/~murdock/copy.html">copy</a></p></li><li><p><code>[2]</code> <a href="https://home.csulb.edu/~murdock/xcopy.html">xcopy</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> dos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dos </tag>
            
            <tag> commands </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c程序定位段错误segment fault</title>
      <link href="/2022/05/28/c%E7%A8%8B%E5%BA%8F%E5%AE%9A%E4%BD%8D%E6%AE%B5%E9%94%99%E8%AF%AFsegment-fault/"/>
      <url>/2022/05/28/c%E7%A8%8B%E5%BA%8F%E5%AE%9A%E4%BD%8D%E6%AE%B5%E9%94%99%E8%AF%AFsegment-fault/</url>
      
        <content type="html"><![CDATA[<h1 id="c程序定位段错误segment-fault"><a href="#c程序定位段错误segment-fault" class="headerlink" title="c程序定位段错误segment fault"></a>c程序定位段错误segment fault</h1><ul><li>在编写c语言程序时，会经常不小心写出 段错误 的bug代码，但是又不知道导致段错误的代码，有小伙伴会说，可以gdb一行一行地调试啊，虽然这样是可以的，但是效率太低，接下来我会演示一下如何定位段错误的位置</li></ul><h2 id="首先要了解段错误"><a href="#首先要了解段错误" class="headerlink" title="首先要了解段错误"></a>首先要了解段错误</h2><h3 id="导致段错误的原因"><a href="#导致段错误的原因" class="headerlink" title="导致段错误的原因"></a>导致段错误的原因</h3><ul><li>一般有四种原因<ol><li>访问了非法内存: <code>int* p = NULL; printf("%d\n", *p);</code></li><li>数组越界: <code>int a[4]; a[4] = 1;</code> 数组越界存在不确定因素，有时候会出现段错误，有时候不会</li><li>scanf错误使用: <code>int a; scanf("%d", a);</code></li><li>指针访问只读内存： <code>char* str = "111"; str[0] = 'a';</code></li></ol></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul><li><p>编写代码：<code>segment.c</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    *p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>编译并运行:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos c]<span class="comment"># gcc -g segment.c</span></span><br><span class="line">[root@VM-16-5-centos c]<span class="comment"># ./a.out</span></span><br><span class="line">Segmentation fault</span><br><span class="line">[root@VM-16-5-centos c]<span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>如上所示，执行程序的时候，报段错误，但是没有生成 <code>core</code> 文件，所以需要手动设置一下 <a href="https://www.linuxcool.com/ulimit">ulimit</a><sup>1</sup> 然后再运行，并查看生成的core文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos c]<span class="comment"># ulimit -c unlimited</span></span><br><span class="line">[root@VM-16-5-centos c]<span class="comment"># ./a.out</span></span><br><span class="line">Segmentation fault (core dumped)</span><br><span class="line">[root@VM-16-5-centos c]<span class="comment"># ls</span></span><br><span class="line">a.out  core.26602  error.txt  pipe.c  read_pipe.c  segment.c  simulate_commands  write_pipe.c</span><br></pre></td></tr></tbody></table></figure></li><li><p>如上图所示中的 <code>core.26602</code> 就是生成的段错误文件，接下来我们要进入gdb来分析该 core文件定位导致段错误的位置</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos c]<span class="comment"># gdb a.out core.26602</span></span><br><span class="line">GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-120.el7</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-redhat-linux-gnu"</span>.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</span><br><span class="line">Reading symbols from /root/files/blend/gitpros/linux/coding/c/a.out...done.</span><br><span class="line">[New LWP 27251]</span><br><span class="line">Core was generated by `./a.out<span class="string">'.</span></span><br><span class="line"><span class="string">Program terminated with signal 11, Segmentation fault.</span></span><br><span class="line"><span class="string">#0  0x00000000004004fd in main () at segment.c:6</span></span><br><span class="line"><span class="string">6*p = 1;</span></span><br><span class="line"><span class="string">Missing separate debuginfos, use: debuginfo-install glibc-2.17-325.el7_9.x86_64</span></span><br><span class="line"><span class="string">(gdb) </span></span><br></pre></td></tr></tbody></table></figure></li><li><p>从以上的gdb信息就可以看到导致段错误的代码位置: </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Program terminated with signal 11, Segmentation fault.</span><br><span class="line"><span class="comment">#0  0x00000000004004fd in main () at segment.c:6</span></span><br><span class="line">6*p = 1;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><code>[1]</code> <a href="https://www.linuxcool.com/ulimit">ulimit</a></li></ul><h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h2><ul><li><code>ulimit</code></li><li><code>gdb a.out core</code></li><li><code>gcc -g segment.c</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> linux </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现linux的cat命令</title>
      <link href="/2022/05/27/%E5%AE%9E%E7%8E%B0linux%E7%9A%84cat%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/05/27/%E5%AE%9E%E7%8E%B0linux%E7%9A%84cat%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="实现linux的cat命令"><a href="#实现linux的cat命令" class="headerlink" title="实现linux的cat命令"></a>实现linux的cat命令</h1><h2 id="cat命令简介"><a href="#cat命令简介" class="headerlink" title="cat命令简介"></a>cat命令简介</h2><ul><li>首先linux的命令手册: <code>man cat</code>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat - concatenate files and print on the standard output</span><br></pre></td></tr></tbody></table></figure></li><li><a href="https://www.linuxcool.com/cat">cat</a><sup>1</sup>: 在终端设备上显示文件内容，其功能是用于查看文件内容</li></ul><h2 id="C代码实现"><a href="#C代码实现" class="headerlink" title="C代码实现"></a>C代码实现</h2><ul><li><p>首先看几个函数</p><ul><li><a href="https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm">fopen</a><sup>2</sup>: The C library function <code>FILE *fopen(const char *filename, const char *mode)</code> opens the filename pointed to, by filename using the given mode.<ul><li>打开文件，返回文件指针</li><li>example: <code>FILE* fp = fopen("test.txt", "r");</code></li></ul></li><li><a href="https://www.tutorialspoint.com/c_standard_library/c_function_fread.htm">fread</a><sup>3</sup>: The C library function size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) reads data from the given stream into the array pointed to, by ptr.<ul><li>从文件中读取字节</li><li>example: <code>int len = fread(buffer, 1, 5, fp);</code></li></ul></li><li><a href="https://www.tutorialspoint.com/c_standard_library/c_function_fprintf.htm">fprintf</a><sup>4</sup>: The C library function int fprintf(FILE *stream, const char *format, …) sends formatted output to a stream.<ul><li>格式化输出到流</li><li>examples:<ul><li>格式化输出到标准输出流: <code>fprintf(stdout, "this is standard output!\n")</code>, 相当于 <code>printf</code></li><li>格式化输出到标准错误流: <code>fprintf(stderr, "this is standard error!\n")</code></li></ul></li></ul></li><li><a href="https://www.tutorialspoint.com/c_standard_library/c_function_fclose.htm">fclose</a><sup>5</sup>: The C library function int fclose(FILE *stream) closes the stream. All buffers are flushed.<ul><li>关闭文件流</li><li>example: <code>fclose(fp)</code></li></ul></li><li><a href="https://linux.die.net/man/2/access">access</a><sup>6</sup>: access - check real user’s permissions for a file<ul><li>判断是否具有文件操作的权限</li><li>examples:<ul><li>判断文件是否存在: <code>if (access(file_path, F_OK) == 0){}</code></li><li>判断是否可以读取文件: <code>if (access(file_path, R_OK) == 0){}</code></li><li>判断是否可以写入文件: <code>if (access(file_path, W_OK) == 0){}</code></li></ul></li></ul></li><li><a href="https://man7.org/linux/man-pages/man3/getline.3.html">getline</a><sup>7</sup>: reads an entire line from stream,<ul><li>从流中读取一整行</li><li>example: <code>ssize_t read = getline(&amp;buffer, &amp;len, stdin);</code></li></ul></li></ul></li><li><p>创建 <code>mycat.c</code></p></li><li><p><code>cat</code> 命令需要接文件参数，引入参数</p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>{<span class="keyword">return</span> <span class="number">0</span>;}</span><br></pre></td></tr></tbody></table></figure></li><li><p>判断参数的个数，如果小于等于1个参数需要按行输出用户的输入</p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// take user's input and output it by line</span></span><br><span class="line"><span class="type">char</span>* line;</span><br><span class="line"><span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="type">ssize_t</span> read;</span><br><span class="line"><span class="keyword">while</span> ((read = getline(&amp;line, &amp;len, <span class="built_in">stdin</span>) != <span class="number">-1</span>))</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, line);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (line)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">free</span>(line);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>定义一个专门显示文件内容的函数</p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">show_file_content</span><span class="params">(<span class="type">char</span>* file_path)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (access(file_path, R_OK) == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        FILE* fp = fopen(file_path, <span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">char</span> buffer[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (len = fread(buffer, <span class="number">1</span>, <span class="number">4</span>, fp))</span><br><span class="line">            {</span><br><span class="line">                buffer[len] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, buffer);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"file open error\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"mycat: 1: No such file or directory\n"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>接下来是main函数的调用:</p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">        {</span><br><span class="line">            show_file_content(argv[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// take user's input and output it</span></span><br><span class="line">        <span class="type">char</span>* line;</span><br><span class="line">        <span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ssize_t</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = getline(&amp;line, &amp;len, <span class="built_in">stdin</span>) != <span class="number">-1</span>))</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s"</span>, line);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (line)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">free</span>(line);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>全部代码: <code>mycat.c</code></p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_file_content</span><span class="params">(<span class="type">char</span>* file_path)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (access(file_path, R_OK) == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        FILE* fp = fopen(file_path, <span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">char</span> buffer[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (len = fread(buffer, <span class="number">1</span>, <span class="number">4</span>, fp))</span><br><span class="line">            {</span><br><span class="line">                buffer[len] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, buffer);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"file open error\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"mycat: 1: No such file or directory\n"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">        {</span><br><span class="line">            show_file_content(argv[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// take user's input and output it</span></span><br><span class="line">        <span class="type">char</span>* line;</span><br><span class="line">        <span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ssize_t</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = getline(&amp;line, &amp;len, <span class="built_in">stdin</span>) != <span class="number">-1</span>))</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s"</span>, line);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (line)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">free</span>(line);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ul><li>先编译: <code>gcc mycat.c -o mycat</code></li><li>无参数运行: <code>./mycat</code> <code>Ctrl + D</code> 结束输入  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos simulate_commands]# ./mycat</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">my name is smx</span><br><span class="line">my name is smx</span><br><span class="line">how are you today</span><br><span class="line">how are you today</span><br><span class="line">bye</span><br><span class="line">bye</span><br></pre></td></tr></tbody></table></figure></li><li>带参数运行: <code>./mycat 1.txt 2.txt</code></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><code>[1]</code> <a href="https://www.linuxcool.com/cat">cat命令详细介绍</a></li><li><code>[2]</code> <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm">fopen c函数</a></li><li><code>[3]</code> <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fread.htm">fread c函数</a></li><li><code>[4]</code> <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fprintf.htm">fprintf c函数</a></li><li><code>[5]</code> <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fclose.htm">fclose c函数</a></li><li><code>[6]</code> <a href="https://linux.die.net/man/2/access">access c函数</a></li><li><code>[7]</code> <a href="https://man7.org/linux/man-pages/man3/getline.3.html">getline c函数</a></li></ul><h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h2><ul><li>c函数<ul><li><code>fopen</code>、<code>fread</code>、<code>fprintf</code>、<code>fclose</code>、<code>access</code>、 <code>getline</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
