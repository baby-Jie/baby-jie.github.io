<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux和windows下文本文件的换行区别</title>
      <link href="/2022/06/18/linux%E5%92%8Cwindows%E4%B8%8B%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E6%8D%A2%E8%A1%8C%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/06/18/linux%E5%92%8Cwindows%E4%B8%8B%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E6%8D%A2%E8%A1%8C%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="linux和windows下文本文件的换行区别"><a href="#linux和windows下文本文件的换行区别" class="headerlink" title="linux和windows下文本文件的换行区别"></a>linux和windows下文本文件的换行区别</h1><ul><li>先说结论：linux下的行是以 <code>\n</code> 结尾来换行，而windows下的行是以 <code>\r\n</code> 结尾来换行</li></ul><h2 id="Linux环境下"><a href="#Linux环境下" class="headerlink" title="Linux环境下"></a>Linux环境下</h2><ul><li><p>我们先在linux环境中创建一个 <code>test.txt </code> 文本文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">34 5</span><br></pre></td></tr></tbody></table></figure></li><li><p>然后我们用命令 <code>cat -A test.txt</code> 查看一下该文本文件内容</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1$</span><br><span class="line">2$</span><br><span class="line">3^I4 5$</span><br></pre></td></tr></tbody></table></figure><ul><li><code>cat -A</code>: 能够打印文本文件中的非打印字符<ul><li><code>$</code>: 表示 换行符<code>\n</code> 10</li><li><code>^I</code>: 表示制表符 <code>\t</code></li><li><code> </code>: 表示空格</li><li><code>^M</code>: 表示回车符 <code>\r</code></li></ul></li><li>可以看到，linux下文本文件以 <code>\n</code> 作为换行依据</li></ul></li></ul><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><ul><li><p>还是创建一个 <code>test.txt</code> 文本文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">34 5</span><br></pre></td></tr></tbody></table></figure></li><li><p>在windows下使用 <code>git bash</code>， 以便于执行 <code>linux</code> 命令 <code>cat -A test.txt</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1^M$</span><br><span class="line">2^M$</span><br><span class="line">3^I4 5</span><br></pre></td></tr></tbody></table></figure><ul><li>可以看出，windows环境下，文本文件的换行是通过 <code>\r\n</code> 实现的</li></ul></li></ul><h2 id="Windows和Linux文本文件相互转换"><a href="#Windows和Linux文本文件相互转换" class="headerlink" title="Windows和Linux文本文件相互转换"></a>Windows和Linux文本文件相互转换</h2><ul><li>linux一般自带 <code>dos2unix</code> and <code>unix2dos</code> 命令</li></ul><h3 id="dos2unix"><a href="#dos2unix" class="headerlink" title="dos2unix"></a>dos2unix</h3><ul><li>使用方法: <code>dos2unix test.txt</code></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat -A test.txt</span><br><span class="line">1^M$</span><br><span class="line">2^M$</span><br><span class="line">3^I4 5</span><br><span class="line">$ dos2unix test.txt</span><br><span class="line">dos2unix: converting file test.txt to Unix format...</span><br><span class="line">$ cat -A test.txt</span><br><span class="line">1$</span><br><span class="line">2$</span><br><span class="line">3^I4 5</span><br></pre></td></tr></tbody></table></figure><ul><li>自己用命令实现: <code>sed -i 's/\r// test.txt'</code></li></ul><h3 id="unix2dos"><a href="#unix2dos" class="headerlink" title="unix2dos"></a>unix2dos</h3><ul><li>使用方法: <code>unix2dos test.txt</code></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat -A test.txt</span><br><span class="line">1$</span><br><span class="line">2$</span><br><span class="line">3^I4 5</span><br><span class="line">$ unix2dos test.txt</span><br><span class="line">unix2dos: converting file test.txt to DOS format...</span><br><span class="line">$ cat -A test.txt</span><br><span class="line">1^M$</span><br><span class="line">2^M$</span><br><span class="line">3^I4 5</span><br></pre></td></tr></tbody></table></figure><ul><li>自己用命令实现: <ul><li>不完善，有bug: <code>sed -i 's/$/\r/' test.txt</code>，最后一行有问题</li></ul></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://www.cyberciti.biz/faq/howto-unix-linux-convert-dos-newlines-cr-lf-unix-text-format/"></a><a href="https://www.cyberciti.biz/faq/howto-unix-linux-convert-dos-newlines-cr-lf-unix-text-format/">HowTo: UNIX / Linux Convert DOS Newlines CR-LF to Unix/Linux Format</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dos命令del与rd</title>
      <link href="/2022/06/18/dos%E5%91%BD%E4%BB%A4del%E4%B8%8Erd/"/>
      <url>/2022/06/18/dos%E5%91%BD%E4%BB%A4del%E4%B8%8Erd/</url>
      
        <content type="html"><![CDATA[<h1 id="dos命令del与rd"><a href="#dos命令del与rd" class="headerlink" title="dos命令del与rd"></a>dos命令del与rd</h1><h2 id="del命令"><a href="#del命令" class="headerlink" title="del命令"></a>del命令</h2><ul><li>del: 删除文件</li><li>options:<ul><li><code>/q</code>: 安静模式，删除全局通配符时，不要求确认</li><li><code>/s</code>: 递归删除子目录中的文件（但是不会删除子目录）</li></ul></li><li>notes: <ul><li><code>/q /s</code> 要这么用，不能连着用: <code>/qs</code></li></ul></li></ul><h2 id="rd命令"><a href="#rd命令" class="headerlink" title="rd命令"></a>rd命令</h2><ul><li><code>rd</code> 是 <code>rmdir</code> 的缩写，两个命令是等价的，用于删除文件夹和文件</li><li>options:<ul><li><code>/q</code>: 安静模式，带 <code>/s</code> 删除目录树时不要求确认</li><li><code>/s</code>: 递归删除子目录和子文件</li></ul></li><li>notes:<ul><li><code>/q /s</code> 要这么用，不能连着用: <code>/qs</code></li></ul></li></ul><h2 id="questions"><a href="#questions" class="headerlink" title="questions"></a>questions</h2><ul><li>删除某个当前目录下所有的日志文件（以.log结尾）: <code>del /q *.log</code></li><li>删除当前目录下所有文件: <code>del /q *</code></li><li><code>del /q /s *</code> 会发生什么：删除当前目录下所有文件和递归删除子目录下的所有文件（不会删除子目录）</li><li>删除test文件夹: <code>rd /q /s  test</code></li></ul><h2 id="practices"><a href="#practices" class="headerlink" title="practices"></a>practices</h2><ul><li><p>准备 <code>prepare.bat</code></p><figure class="highlight bat"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">md</span> test</span><br><span class="line"><span class="built_in">cd</span> test </span><br><span class="line"><span class="built_in">echo</span> <span class="number">1</span>.txt &gt; <span class="number">1</span>.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="number">2</span>.txt &gt; <span class="number">2</span>.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="number">3</span>.txt &gt; <span class="number">3</span>.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="number">1</span>.txt &gt; <span class="number">1</span>.bak</span><br><span class="line"><span class="built_in">md</span> subfolder</span><br><span class="line"><span class="built_in">cd</span> subfolder</span><br><span class="line"><span class="built_in">echo</span> sub.txt &gt; sub.txt</span><br></pre></td></tr></tbody></table></figure></li><li><p>删除 test 目录下的所有的 以<code>txt</code>结尾文件: <code>del /q *.txt</code></p></li><li><p>删除 test 目录下的所有文件(包括子文件夹中的文件，不删除目录): <code>del /q /s *</code></p></li><li><p>删除test目录: <code>rd /q /s test</code></p></li></ul><h2 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h2><ul><li><p>如何以不显示控制台的方式执行一个bat脚本:</p><ol><li><p>使用vb脚本去运行bat脚本</p><figure class="highlight vb"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> shell=wscript.createObject(<span class="string">"wscript.shell"</span>)</span><br><span class="line">run=shell.Run(<span class="string">"F:\softwares\quick\scripts\work\test.bat"</span>, <span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><ul><li><code>0</code>: 不显示控制台</li><li><code>1</code>: 显示控制台</li></ul></li><li><p>将bat脚本转成exe文件</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> dos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dos </tag>
            
            <tag> commands </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows和linux中文本文件中的换行</title>
      <link href="/2022/06/17/windows%E5%92%8Clinux%E4%B8%AD%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C/"/>
      <url>/2022/06/17/windows%E5%92%8Clinux%E4%B8%AD%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux sed命令，强大的文本处理命令</title>
      <link href="/2022/06/16/linux-sed%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/06/16/linux-sed%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="linux-sed命令，强大的文本处理命令"><a href="#linux-sed命令，强大的文本处理命令" class="headerlink" title="linux:sed命令，强大的文本处理命令"></a>linux:sed命令，强大的文本处理命令</h1><h2 id="sed命令简介"><a href="#sed命令简介" class="headerlink" title="sed命令简介"></a>sed命令简介</h2><ul><li>在 <code>&lt;&lt;Linux命令、编辑器与shell编程&gt;&gt;</code> 这本书中，将 <code>sed</code> 看作是一个编辑器，可见该命令功能的强大</li><li>sed：<code>stream editor</code> 流编辑器，是一个批处理（非交互式）编辑器。它可以变换来自文件或标准输入和输入流。它常被用作管道中的过滤器。由于sed仅仅对其输入扫描一次，因此它比其他交互式编辑器(如 ed)更加高效。</li><li>sed 有多种版本，linux上一般是 <code>GNU sed</code>，mac上用的是 <code>BSD sed</code>，本文除非特别说明，否则默认为 <code>GNU sed</code></li></ul><h3 id="sed命令格式"><a href="#sed命令格式" class="headerlink" title="sed命令格式"></a>sed命令格式</h3><ul><li>命令行语法:<ol><li><code>sed [-n] program [file-list]</code></li><li><code>sed [-n] -f program-file [file-list]</code></li></ol></li><li>第一种直接写命令，第二种是将命令写在文件中。</li></ul><h3 id="sed命令可以做什么"><a href="#sed命令可以做什么" class="headerlink" title="sed命令可以做什么"></a>sed命令可以做什么</h3><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li><p><code>a:append</code> 追加文本 (追加换行符和文本)</p><ul><li><p>文本文件：<code>test</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">my name is </span><br><span class="line">smx</span><br></pre></td></tr></tbody></table></figure></li><li><p>命令: <code>sed 'a yes' test</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">yes</span><br><span class="line">my name is </span><br><span class="line">yes</span><br><span class="line">smx</span><br><span class="line">yes</span><br></pre></td></tr></tbody></table></figure></li><li><p>sed命令始终输出追加命令: <code>sed -n 'a yes' test</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yes</span><br><span class="line">yes</span><br><span class="line">yes</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习:"></a>练习:</h2><ol><li>删除文本文件 <code>test</code> 中的空行</li><li>删除文本文件 <code>test2</code> 中的空白行</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mvvm:wpf事件binding command</title>
      <link href="/2022/06/16/mvvm-wpf%E4%BA%8B%E4%BB%B6binding-command/"/>
      <url>/2022/06/16/mvvm-wpf%E4%BA%8B%E4%BB%B6binding-command/</url>
      
        <content type="html"><![CDATA[<h1 id="MVVM-WPF事件Binding-Command"><a href="#MVVM-WPF事件Binding-Command" class="headerlink" title="MVVM:WPF事件Binding Command"></a>MVVM:WPF事件Binding Command</h1><ul><li><p>我们知道 <code>Button</code> 控件有 <code>Command</code> 依赖属性，可以用来绑定我们定义在 <code>ViewModel</code> 中的 <code>RelayCommand</code>，当 <code>Button</code> 被点击的时候就会自动执行 我们定义的<code>RelayCommand</code></p></li><li><p>但是其他控件比如 <code>Label</code> 这些没有 <code>Command</code> 依赖属性的怎么绑定 <code>RelayCommand</code>，比如 <code>Label</code>的左击事件怎么绑定 <code>RelayCommand</code>。</p></li><li><p>这个时候就要用到 <code>EventTrigger</code> and <code>InvokeCommandAction</code></p><ul><li>以前我们需要找到 <code>System.Windows.Interactivity.dll</code> 引入我们的项目</li><li>现在微软退出了新的nuget包，我们以新的nuget包示例</li></ul></li><li><p>引入 nuget 包： <code>Microsoft.Xaml.Behaviors.Wpf</code></p></li><li><p>xaml代码:</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Window</span> <span class="attr">x:Class</span>=<span class="string">"CommandBindingEvent.MainWindow"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns</span>=<span class="string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:x</span>=<span class="string">"http://schemas.microsoft.com/winfx/2006/xaml"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:behaviors</span>=<span class="string">"http://schemas.microsoft.com/xaml/behaviors"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Grid</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Label</span> <span class="attr">Content</span>=<span class="string">"Hello WPF!"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">behaviors:Interaction.Triggers</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">behaviors:EventTrigger</span> <span class="attr">EventName</span>=<span class="string">"MouseLeftButtonDown"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">behaviors:InvokeCommandAction</span> <span class="attr">Command</span>=<span class="string">"{Binding HelloCmd}"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">behaviors:EventTrigger</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">behaviors:Interaction.Triggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Window</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>ViewModel代码:</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RelayArgCommand _helloCmd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> RelayArgCommand HelloCmd</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> _helloCmd ?? (_helloCmd = <span class="keyword">new</span> RelayArgCommand((e) =&gt;</span><br><span class="line">                                                             {</span><br><span class="line">                                                                 MessageBox.Show(<span class="string">"hello wpf!"</span>);</span><br><span class="line">                                                             }));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>但是，经过断点调试，我们发现 <code>Command</code> 中的 <code>e</code> 为null，事件一般有两个参数: <code>private void XXX_OnXX(object sender, RoutedEventArgs e)</code>，我们想要通过这两个参数进行其他操作怎么办？</p><ul><li><p><img src="/..%5Cimages%5Cmvvmwpf%E4%BA%8B%E4%BB%B6binding_command%5C1.jpg" alt="image"></p></li><li><p><code>InvokeCommandAction</code> 中需要设置一个参数即可，<code>sender</code> 可通过 <code>e.Source</code> 获得</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;behaviors:InvokeCommandAction Command="{Binding HelloCmd}" PassEventArgsToCommand="True" /&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li><img src="/..%5Cimages%5Cmvvmwpf%E4%BA%8B%E4%BB%B6binding_command%5C2.jpg" alt="image2"></li></ul></li></ul></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/baby-Jie/blog_codes/tree/main/dotnet/wpf/CommandBindingEvent">code</a></li><li><a href="https://devblogs.microsoft.com/dotnet/open-sourcing-xaml-behaviors-for-wpf/">behaviors</a></li><li><a href="https://www.nuget.org/packages/Microsoft.Xaml.Behaviors.Wpf/">nuget</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> wpf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wpf </tag>
            
            <tag> mvvm </tag>
            
            <tag> binding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速打开环境变量面板</title>
      <link href="/2022/06/15/%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%9D%A2%E6%9D%BF/"/>
      <url>/2022/06/15/%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%9D%A2%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="快速打开环境变量面板"><a href="#快速打开环境变量面板" class="headerlink" title="快速打开环境变量面板"></a>快速打开环境变量面板</h1><ul><li><p>如果想要添加一个环境变量你会怎么做？</p><ul><li>使用命令行 <code>setx JAVA_HOME d:\\libs\\jdk</code><ul><li>单纯的加环境变量还好，但是如果往 <code>PATH</code> 中添加路径有两个致命的缺点<ol><li>命令没写好，导致PATH路径被覆盖</li><li>PATH长度大于1024，不可写入</li></ol></li></ul></li><li>使用图形化界面<ul><li>打开设置 -&gt; 找到关于 -&gt; 点击高级系统设置 -&gt; 选择高级tab -&gt; 点击环境变量</li><li><img src="/../images/%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%9D%A2%E6%9D%BF/%E6%89%93%E5%BC%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%9D%A2%E6%9D%BFui.jpg" alt="image"></li></ul></li></ul></li><li><p>可以看出以上两种方式都不太便捷，那么，有没有比较快捷的方法呢？有，你可以执行以下命令(运行处<kbd>Win</kbd>+<kbd>r</kbd>):</p><ul><li><code>rundll32 sysdm.cpl,EditEnvironmentVariables</code></li><li><img src="/../images/%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%9D%A2%E6%9D%BF/%E6%89%93%E5%BC%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%9D%A2%E6%9D%BF%E5%BF%AB%E6%8D%B7%E5%91%BD%E4%BB%A4.jpg" alt="image"></li></ul></li><li><p>但是这么长的命令，又难记，又费时间怎么办？写一个脚本执行即可 <code>env.bat</code></p><figure class="highlight bat"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">start</span> /b rundll32 sysdm.cpl,EditEnvironmentVariables</span><br></pre></td></tr></tbody></table></figure></li><li><p>然后将这个脚本创建一个快捷方式，名字就命名为 <code>env</code>, 随后将这个快捷方式放到，环境变量PATH路径中</p><ul><li><img src="/../images/%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%9D%A2%E6%9D%BF/env.jpg" alt="env"></li><li><img src="/../images/%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%9D%A2%E6%9D%BF/env2.jpg" alt="env"></li></ul></li><li><p>接下来我们只要在 运行处 键入: <code>env</code> 命令就可快速打开变量面板了</p><ul><li><img src="/../images/%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%9D%A2%E6%9D%BF/env3.jpg" alt="env"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> dos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dos </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux程序以后台方式启动</title>
      <link href="/2022/06/14/linux%E7%A8%8B%E5%BA%8F%E4%BB%A5%E5%90%8E%E5%8F%B0%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8/"/>
      <url>/2022/06/14/linux%E7%A8%8B%E5%BA%8F%E4%BB%A5%E5%90%8E%E5%8F%B0%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>springmvc请求参数详解</title>
      <link href="/2022/06/13/springmvc%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/06/13/springmvc%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-MVC-请求参数详解"><a href="#Spring-MVC-请求参数详解" class="headerlink" title="Spring MVC 请求参数详解"></a>Spring MVC 请求参数详解</h1><ul><li>Http请求参数分为两种<ol><li>url拼接参数</li><li>请求体参数</li></ol></li></ul><h2 id="code-准备"><a href="#code-准备" class="headerlink" title="code 准备"></a>code 准备</h2><ul><li><p><code>User.java</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>{</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="获取请求参数的五种方式"><a href="#获取请求参数的五种方式" class="headerlink" title="获取请求参数的五种方式"></a>获取请求参数的五种方式</h2><h3 id="SevletApi方式获取请求参数"><a href="#SevletApi方式获取请求参数" class="headerlink" title="SevletApi方式获取请求参数"></a>SevletApi方式获取请求参数</h3><ul><li><p>在请求方法种添加 <code>HttpServletRequest</code> 类型参数，并通过调用 <code>requestParam</code> 获取参数，此方法比较原始.</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping("/user01")</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">servletApi</span><span class="params">(HttpServletRequest request)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> request.getParameter(<span class="string">"userName"</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> request.getParameter(<span class="string">"sex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUserName(userName);</span><br><span class="line">    user.setSex(sex);</span><br><span class="line">    user.setDescription(<span class="string">"servletApi in ParameterGetController"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul><li><p><code>Get/Post/Put http://localhost:9000/user01</code> body: none</p><ul><li><p>reponse:</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sex"</span><span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">"servletApi in ParameterGetController"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>因为没有带拼接url参数，所以通过 <code>request.getParam(key)</code> 获取到的值都为null</p></li></ul></li><li><p><code>Get/Post/Put http://localhost:9000/user01?userName=smx&amp;sex=male</code> body:none</p><ul><li><p>response:</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="string">"smx"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sex"</span><span class="punctuation">:</span> <span class="string">"male"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">"servletApi in ParameterGetController"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>因为带了拼接url参数，所以通过 <code>request.getParam(key)</code> 可以获取到对应的值</p></li></ul></li><li><p>带有body的请求，因为该方法只用了 <code>request.getParam(key)</code> 只能获取拼接url参数，所以这里就举例带有body的请求了。</p></li></ul><h3 id="方法同名参数接收请求参数"><a href="#方法同名参数接收请求参数" class="headerlink" title="方法同名参数接收请求参数"></a>方法同名参数接收请求参数</h3><ul><li><p>在请求方法中，使用和请求参数同名的参数:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping("/user02")</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">funParam</span><span class="params">(String userName, String sex)</span> {</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUserName(userName);</span><br><span class="line">    user.setSex(sex);</span><br><span class="line">    user.setDescription(<span class="string">"funParam in ParameterGetController"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><ul><li><p><code>Get/Post/Put http://localhost:9000/user02</code> body:none</p><ul><li><p>response: </p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sex"</span><span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">"funParam in ParameterGetController"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>因为请求既没有拼接参数，也没有body，自然接收到的参数为null</p></li></ul></li><li><p><code>Get/Post/Put http://localhost:9000/user02?userName=smx&amp;sex=male</code> body: none</p><ul><li><p>response:</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="string">"smx"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sex"</span><span class="punctuation">:</span> <span class="string">"male"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">"funParam in ParameterGetController"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>该方法可以接收拼接参数</p></li></ul></li><li><p><code>Post/Put http://localhost:9000/user02</code> <code>Content-Type: application/x-www-form-urlencoded</code></p><ul><li><p>body:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userName:smx_urlencoded</span><br><span class="line">sex:male_urlencoded</span><br></pre></td></tr></tbody></table></figure></li><li><p>response:</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="string">"smx_urlencoded"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sex"</span><span class="punctuation">:</span> <span class="string">"male_urlencoded"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">"funParam in ParameterGetController"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>可见，该方法不仅能接收拼接参数，而且还能接收 <code>body</code> 参数 (post or put method, get方法不能接收body参数)</p></li></ul></li><li><p>那么请求既带拼接参数，又带body参数又该怎么样呢？请求 <code>POST http://localhost:9000/user02?userName=smx&amp;sex=male</code></p><ul><li><p><code>Content-Type: application/x-www-form-urlencoded</code></p></li><li><p>body:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userName:smx_urlencoded</span><br><span class="line">sex:male_urlencoded</span><br></pre></td></tr></tbody></table></figure></li><li><p>response:</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="string">"smx,smx_urlencoded"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sex"</span><span class="punctuation">:</span> <span class="string">"male,male_urlencoded"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">"funParam in ParameterGetController"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>从以上的response可以看到，拼接参数和body参数同名参数自动拼接成一个字符串</p></li><li><p>那么，如果拼接参数和body参数同名且值相同会怎么样？</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="string">"smx,smx"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sex"</span><span class="punctuation">:</span> <span class="string">"male,male"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">"funParam in ParameterGetController"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="使用-RequestParam指定参数名"><a href="#使用-RequestParam指定参数名" class="headerlink" title="使用 @RequestParam指定参数名"></a>使用 @RequestParam指定参数名</h2><ul><li><p>在请求方法中，使用 <code>@RequestParam</code>  指定参数的名字</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping("/user03")</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">funNamedParam</span><span class="params">(<span class="meta">@RequestParam("userName")</span> String name, <span class="meta">@RequestParam("sex")</span> String gender)</span> {</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUserName(name);</span><br><span class="line">    user.setSex(gender);</span><br><span class="line">    user.setDescription(<span class="string">"funNamedParam in ParameterGetController"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>有一点需要注意：<code>RequestParam</code> 中的 <code>required</code> 默认为true，也就是说，一旦被 <code>@RequestParam</code> 标记的参数一定要提供，否咋报错，当然你也可以手动将 <code>required</code>  设置为 <code>false</code> : <code>@RequestParam(value="userName", required=false) String name</code></p></li></ul><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><ul><li>和 <strong>方法同名参数接收请求参数</strong> 测试一致</li></ul><h2 id="使用Bean对象接收参数"><a href="#使用Bean对象接收参数" class="headerlink" title="使用Bean对象接收参数"></a>使用Bean对象接收参数</h2><ul><li><p>在请求方法中，直接使用bean对象去接收请求的参数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping("/user04")</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">beanParam</span><span class="params">(User user)</span> {</span><br><span class="line">    user.setDescription(<span class="string">"beanParam in ParameterGetController"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h3><ul><li>与以上测试一致</li></ul><h2 id="使用-RequestBody-来接收-json数据"><a href="#使用-RequestBody-来接收-json数据" class="headerlink" title="使用 @RequestBody 来接收 json数据"></a>使用 @RequestBody 来接收 json数据</h2><ul><li><p>在请求方法中，直接使用bean对象并且使用 @RequestBody来标记，接收body的json数据</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping("/user05")</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">jsonRequestBody</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> {</span><br><span class="line">    user.setDescription(<span class="string">"jsonRequestBody in ParameterGetController"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>@RequestBody</code>: 主要用来接收前端传递给后端的json字符串种的数据</p><ul><li>一个请求，只有一个RequestBody, 可以有多个 RequestParam</li></ul></li><li><p><code>@RequestBody</code> 只能接收 <code>Content-Type</code> 为 <code>application/json</code> 的请求（body为json)，不会接收 url拼接参数</p></li></ul><h3 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h3><ul><li><p><code>Get/Post/Put http://localhost:9000/user05</code> <code>Content-Type: application/json</code></p><ul><li><p>body:</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="string">"smx_json"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sex"</span><span class="punctuation">:</span> <span class="string">"male_json"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>response:</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="string">"smx_json"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sex"</span><span class="punctuation">:</span> <span class="string">"male_json"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">"jsonRequestBody in ParameterGetController"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="请求体内容"><a href="#请求体内容" class="headerlink" title="请求体内容"></a>请求体内容</h2><ul><li><p>首先我们要在Headers中添加一个 key，为 <code>Content-Type</code>, 表明我们请求体(body)的内容类型 接下来我们仔细研究一下这个 <code>Content-Type</code></p></li><li><p><code>Content-Type</code></p><ul><li><p><code>application/json</code>: 表明 <code>body</code> 内容就是json字符串</p></li><li><p><code>application/x-www-form-urlencoded</code>: 表单提交就是以这种方式，body内容为key value值的拼接，例如: <code>userName=smx&amp;sex=male</code></p></li><li><p><code>multipart/form-data</code></p><ul><li><p><code>Content-Type</code> 中不仅要设置为 <code>multipart/form-data</code> 还要设置自定义边界</p><ul><li><p>例如: <code>Content-Type: multipart/form-data; boundary=--smx</code></p></li><li><p>那么 body 就应该设置为</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">----smx</span><br><span class="line">Content-Disposition: form-data; name="userName"</span><br><span class="line"></span><br><span class="line">smx</span><br><span class="line">----smx</span><br><span class="line">Content-Disposition: form-data; name="sex"</span><br><span class="line"></span><br><span class="line">male</span><br><span class="line">----smx--</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>html中利用form来提交 <code>form-data</code> 数据</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span> <span class="attr">action</span>=<span class="string">"http://localhost:9000/user04"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">value</span>=<span class="string">"smx"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>性别:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"male"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>查看请求源码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryvGgpig5EBnllnkJb</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryvGgpig5EBnllnkJb</span><br><span class="line">Content-Disposition: form-data; name="userName"</span><br><span class="line"></span><br><span class="line">smx</span><br><span class="line">------WebKitFormBoundaryvGgpig5EBnllnkJb</span><br><span class="line">Content-Disposition: form-data; name="sex"</span><br><span class="line"></span><br><span class="line">male</span><br><span class="line">------WebKitFormBoundaryvGgpig5EBnllnkJb--</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th align="center">参数请求方式</th><th align="center">servlet api方式获取参数</th><th align="center">同名参数获取方式</th><th align="center">指定参数名称获取方式</th><th align="center">bean对象方式</th><th align="center">@RequestBody方式</th><th align="center">get请求</th><th align="center">post请求</th><th align="center">put请求</th></tr></thead><tbody><tr><td align="center">url拼接参数</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">form-data</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">x-www-form-urlencoded</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">application/json</td><td align="center">×</td><td align="center">×</td><td align="center">×</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> RequestBody </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux命令tar的使用</title>
      <link href="/2022/06/08/linux%E5%91%BD%E4%BB%A4tar%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/06/08/linux%E5%91%BD%E4%BB%A4tar%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="linux命令tar的使用"><a href="#linux命令tar的使用" class="headerlink" title="linux命令tar的使用"></a>linux命令tar的使用</h1><ul><li>tar命令用于打包、解包、压缩、解压缩文件，能够制作出linux系统中常见的 <code>.tar</code>、<code>.tar.gz</code>、<code>.tar.bz2</code>等格式的压缩包文件。</li></ul><h2 id="options"><a href="#options" class="headerlink" title="options"></a>options</h2><ul><li><code>-c</code>: 建立新的备份文件</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> commands </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式：单例模式</title>
      <link href="/2022/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式：单例模式"><a href="#设计模式：单例模式" class="headerlink" title="设计模式：单例模式"></a>设计模式：单例模式</h1><ul><li>单例模式是一种非常简单且容易理解的设计模式。顾名思义，单例即单一的实例。确切地讲，就是指在某个系统中只存在一个实例。例如宇宙中只有一个太阳。</li><li>单例模式一般有两种实现方式：饿汉式和饱汉式</li><li>创建单例模式一般遵循这几个规则:<ol><li>构造函数私有化</li><li>提供获取单例的方法，暴露给外部使用</li></ol></li></ul><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><ul><li><p>顾名思义，就是一开始就创建好实例对象</p></li><li><p>code:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> smx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-06-08 21:41</span></span><br><span class="line"><span class="comment"> * 单例模式: 饿汉式</span></span><br><span class="line"><span class="comment"> * 首先要将构造函数改成私有，防止破坏单例性</span></span><br><span class="line"><span class="comment"> * 直接new一个静态的实例对象</span></span><br><span class="line"><span class="comment"> * 最后通过一个方法 getInstance 来获取单例</span></span><br><span class="line"><span class="comment"> * 为什么不直接 public static SingletonModel instance;  防止对 instance 的修改 破坏单例性</span></span><br><span class="line"><span class="comment"> * 因为是饿汉式，所以是线程安全的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonModel</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonModel</span><span class="params">()</span>{}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonModel</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonModel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonModel <span class="title function_">getInstance</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="饱汉式"><a href="#饱汉式" class="headerlink" title="饱汉式"></a>饱汉式</h2><ul><li><p>简单的饱汉式，第一次用的时候再创建实例，但是在多线程环境下可能会有多个实例，非线程安全</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> smx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-06-08 21:50</span></span><br><span class="line"><span class="comment"> * 饱汉式单例模式：就是第一次用的时候再创建</span></span><br><span class="line"><span class="comment"> * 这种方法在多线程环境下可能出现问题，线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonModel2</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonModel2</span><span class="params">()</span>{}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonModel2 instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonModel2 <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 先判断，是否为null，为null再创建</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">SingletonModel2</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>加锁的饱汉式，虽然是线程安全了，但是十分影响性能，因为每次获取实例都要加锁</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> smx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-06-08 21:52</span></span><br><span class="line"><span class="comment"> * 饱汉式：加锁，线程安全</span></span><br><span class="line"><span class="comment"> * 但是每次获取都要加锁导致性能下降</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonModel3</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonModel3</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonModel3 instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SingletonModel3 <span class="title function_">getInstance</span><span class="params">()</span>{</span><br><span class="line">        <span class="comment">// 每次获取都要加锁，十分影响性能</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">SingletonModel3</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>双重锁、双检锁饱汉式，外层放宽入口，保证线程并发的高效性；内层加锁同步，保证实例化的单次运行，如此里应外合，不仅达到了单例模式的效果，还完美保证了构建过程的运行效率</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> smx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-06-08 21:55</span></span><br><span class="line"><span class="comment"> * 饱汉式：双重锁，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonModel4</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonModel4</span><span class="params">()</span>{}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonModel4 instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonModel4 <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 外层放开入口，保证线程并发的高效性</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonModel4.class) {</span><br><span class="line">                <span class="comment">// 内层加锁同步，保证实例化的单一运行</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingletonModel4</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>除了以上两种实现单例的方式，还有内部类方式等等…</li><li>在实际开发中，最常用的还是饿汉式单例，因为单例迟早是要被实例化的，延迟加载的意义并不大，加锁解锁反而是一种资源的浪费，同步会降低CPU的利用率，使用不当的话反而会带来不必要的风险。越简单的包容性越强，越复杂的反而越容易出错。所以我建议还是饿汉式模式优先。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu下apt的使用</title>
      <link href="/2022/06/08/ubuntu%E4%B8%8Bapt%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/06/08/ubuntu%E4%B8%8Bapt%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu下apt的使用"><a href="#Ubuntu下apt的使用" class="headerlink" title="Ubuntu下apt的使用"></a>Ubuntu下apt的使用</h1><h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><ul><li>安装依赖有版本冲突时: <code>aptitude install xxx</code></li><li>修复已经 <code>failed/broken</code> 包: <code># apt -f install</code></li></ul><h2 id="modify"><a href="#modify" class="headerlink" title="modify"></a>modify</h2><ul><li>更新: <code>apt update</code></li><li>升级: <code>apt upgrade</code></li><li>查看可更新的packages: <code>apt list --upgradable</code></li></ul><h2 id="query"><a href="#query" class="headerlink" title="query"></a>query</h2><ul><li><p>查询已经安装的包: <code>dpkg --list | grep &lt;package-name&gt;</code></p></li><li><p>查询可安装的包列表: <code>apt list</code>，如果已安装的包会在最后显示 <code>installed</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">smx@ubuntu:~/jdk/test$ apt list | grep net-tools</span><br><span class="line"></span><br><span class="line">WARNING: apt does not have a stable CLI interface. Use with caution <span class="keyword">in</span> scripts.</span><br><span class="line"></span><br><span class="line">ddnet-tools/impish 15.5.4-1ubuntu1 amd64</span><br><span class="line">net-tools/impish,now 1.60+git20181103.0eebece-1ubuntu2 amd64 [installed]</span><br><span class="line">net-tools/impish 1.60+git20181103.0eebece-1ubuntu2 i386</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><ul><li><p><code>remove/purge</code>都可以用来卸载包使用, <code>purge</code> 会同时删除配置文件，而<code>remove</code> 不会</p><ul><li><code># apt remove &lt;package-name&gt;</code></li><li><code># apt purge &lt;package-name&gt;</code></li></ul></li><li><p><code>remove/purge</code>除了能够卸载包，还可以安装包</p><ul><li><code># apt &lt;remove/purge&gt; &lt;package-name&gt;+</code></li></ul></li><li><p>clear the cache of <code>old/outdate</code> packages with:  <code># apt clean</code></p></li><li><p>卸载非必要的包: <code># apt auto remove</code></p></li></ul><hr><h2 id="apt-package-samples"><a href="#apt-package-samples" class="headerlink" title="apt package samples"></a>apt package samples</h2><ul><li><code>apt install aptitude</code></li><li><code>apt install vim</code></li><li><code>apt install openjdk-8-jdk</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> software </tag>
            
            <tag> apt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdk的安装</title>
      <link href="/2022/06/07/jdk%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2022/06/07/jdk%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="jdk的安装"><a href="#jdk的安装" class="headerlink" title="jdk的安装"></a>jdk的安装</h1><h2 id="jdk的下载"><a href="#jdk的下载" class="headerlink" title="jdk的下载"></a>jdk的下载</h2>]]></content>
      
      
      <categories>
          
          <category> software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无限背包问题</title>
      <link href="/2022/06/02/%E6%97%A0%E9%99%90%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2022/06/02/%E6%97%A0%E9%99%90%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>01背包问题</title>
      <link href="/2022/06/01/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2022/06/01/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>wpf绑定失败回滚</title>
      <link href="/2022/05/31/wpf%E7%BB%91%E5%AE%9A%E5%A4%B1%E8%B4%A5%E5%9B%9E%E6%BB%9A/"/>
      <url>/2022/05/31/wpf%E7%BB%91%E5%AE%9A%E5%A4%B1%E8%B4%A5%E5%9B%9E%E6%BB%9A/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>链表中的节点每k个翻转</title>
      <link href="/2022/05/30/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%AF%8Fk%E4%B8%AA%E7%BF%BB%E8%BD%AC/"/>
      <url>/2022/05/30/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%AF%8Fk%E4%B8%AA%E7%BF%BB%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="链表中的节点每k个一组翻转"><a href="#链表中的节点每k个一组翻转" class="headerlink" title="链表中的节点每k个一组翻转"></a><strong>链表中的节点每k个一组翻转</strong></h1><ul><li><a href="https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=295&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=/exam/oj">题目链接</a></li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样<br>你不能更改节点中的值，只能更改节点本身。</p><p>数据范围： \ 0 \le n \le 2000 0≤<em>n</em>≤2000 ， 1 \le k \le 20001≤<em>k</em>≤2000 ，链表中每个元素都满足 0 \le val \le 10000≤<em>v<strong>a</strong>l</em>≤1000<br>要求空间复杂度 O(1)<em>O</em>(1)，时间复杂度 O(n)<em>O</em>(<em>n</em>)</p><p>例如：</p><p>给定的链表是 1\to2\to3\to4\to51→2→3→4→5</p><p>对于 k = 2<em>k</em>=2 , 你应该返回 2\to 1\to 4\to 3\to 52→1→4→3→5</p><p>对于 k = 3<em>k</em>=3 , 你应该返回 3\to2 \to1 \to 4\to 53→2→1→4→5</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{1,2,3,4,5},2</span><br></pre></td></tr></tbody></table></figure><p>复制</p><p>返回值：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{2,1,4,3,5}</span><br></pre></td></tr></tbody></table></figure><p>复制</p><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{},1</span><br></pre></td></tr></tbody></table></figure><p>复制</p><p>返回值：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{}</span><br></pre></td></tr></tbody></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li><p>和 <strong>链表内指定区间反转</strong> 一样，首先写一个函数，反转链表前k个节点</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 首先计算该链表的长度len</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode* head2 = head, *tail = head;</span><br><span class="line">    <span class="keyword">while</span> (head2) {head2=head2-&gt;next; len++;}</span><br><span class="line">    <span class="comment">// 长度不足k个节点，直接返回，不逆转</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; k) <span class="keyword">return</span> head;</span><br><span class="line">    head2 = head-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> next = head2-&gt;next;</span><br><span class="line">        head2-&gt;next = head;</span><br><span class="line">        head = head2;</span><br><span class="line">        head2 = next;</span><br><span class="line">    }</span><br><span class="line">    tail-&gt;next = head2;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>接下来的操作很简单，只需要在函数返回前 对剩下来的节点再进行 反转前k个节点 操作即可</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail-&gt;next = <span class="built_in">reverseKGroup</span>(head2, k);</span><br></pre></td></tr></tbody></table></figure></li><li><p>完整代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 首先计算该链表的长度len</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode* head2 = head, *tail = head;</span><br><span class="line">    <span class="keyword">while</span> (head2) {head2=head2-&gt;next; len++;}</span><br><span class="line">    <span class="comment">// 长度不足k个节点，直接返回，不逆转</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; k) <span class="keyword">return</span> head;</span><br><span class="line">    head2 = head-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> next = head2-&gt;next;</span><br><span class="line">        head2-&gt;next = head;</span><br><span class="line">        head = head2;</span><br><span class="line">        head2 = next;</span><br><span class="line">    }</span><br><span class="line">    tail-&gt;next = <span class="built_in">reverseKGroup</span>(head2, k);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 牛客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表内指定区间反转</title>
      <link href="/2022/05/30/%E9%93%BE%E8%A1%A8%E5%86%85%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E5%8F%8D%E8%BD%AC/"/>
      <url>/2022/05/30/%E9%93%BE%E8%A1%A8%E5%86%85%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="链表内指定区间反转"><a href="#链表内指定区间反转" class="headerlink" title="链表内指定区间反转"></a>链表内指定区间反转</h1><ul><li><a href="https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=295&amp;tqId=654&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=/exam/oj">题目链接</a></li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)<em>O</em>(<em>n</em>)，空间复杂度 O(1)<em>O</em>(1)。<br>例如：<br>给出的链表为 1\to 2 \to 3 \to 4 \to 5 \to NULL1→2→3→4→5→<em>N<strong>U</strong>L**L</em>, m=2,n=4<em>m</em>=2,<em>n</em>=4,<br>返回 1\to 4\to 3\to 2\to 5\to NULL1→4→3→2→5→<em>N<strong>U</strong>L**L</em>.</p><p>数据范围： 链表长度 0 &lt; size \le 10000&lt;<em>s<strong>i</strong>z**e</em>≤1000，0 &lt; m \le n \le size0&lt;<em>m</em>≤<em>n</em>≤<em>s<strong>i</strong>z**e</em>，链表中每个节点的值满足 |val| \le 1000∣<em>v<strong>a</strong>l</em>∣≤1000</p><p>要求：时间复杂度 O(n)<em>O</em>(<em>n</em>) ，空间复杂度 O(n)<em>O</em>(<em>n</em>)</p><p>进阶：时间复杂度 O(n)<em>O</em>(<em>n</em>)，空间复杂度 O(1)<em>O</em>(1)</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{1,2,3,4,5},2,4</span><br></pre></td></tr></tbody></table></figure><p>复制</p><p>返回值：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{1,4,3,2,5}</span><br></pre></td></tr></tbody></table></figure><p>复制</p><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{5},1,1</span><br></pre></td></tr></tbody></table></figure><p>复制</p><p>返回值：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{5}</span><br></pre></td></tr></tbody></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><p>首先先写一个链表反转的代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseLinkedList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">auto</span> head2 = head-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (head2)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> next = head2-&gt;next;</span><br><span class="line">        head2-&gt;next = head;</span><br><span class="line">        head = head2;</span><br><span class="line">        head2 = next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>去 <a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=295&amp;tqId=23286&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=/exam/oj">这里</a> 测试代码</li></ul></li><li><p>要想逆转区间内的链表，首先要写一个逆转前k个节点的函数 <code>ReversePreKNode</code>, 并返回逆转后的头节点</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reversePreKNodes</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 首先计算该链表的长度len</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode* head2 = head, *tail = head;</span><br><span class="line">    <span class="keyword">while</span> (head2) {head2=head2-&gt;next; len++;}</span><br><span class="line">    <span class="comment">// 长度不足k个节点，直接返回，不逆转</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; k) <span class="keyword">return</span> head;</span><br><span class="line">    head2 = head-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> next = head2-&gt;next;</span><br><span class="line">        head2-&gt;next = head;</span><br><span class="line">        head = head2;</span><br><span class="line">        head2 = next;</span><br><span class="line">    }</span><br><span class="line">    tail-&gt;next = head2;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>接下来只要找到链表的第 <code>m-1</code> 个节点可以了，完整代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="type">int</span> k = n - m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>)    <span class="keyword">return</span> <span class="built_in">reversePreKNodes</span>(head, k);</span><br><span class="line">    ListNode* head2 = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m<span class="number">-1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        head2 = head2-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    head2-&gt;next = <span class="built_in">reversePreKNodes</span>(head2-&gt;next, k);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reversePreKNodes</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 首先计算该链表的长度len</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode* head2 = head, *tail = head;</span><br><span class="line">    <span class="keyword">while</span> (head2) {head2=head2-&gt;next; len++;}</span><br><span class="line">    <span class="comment">// 长度不足k个节点，直接返回，不逆转</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; k) <span class="keyword">return</span> head;</span><br><span class="line">    head2 = head-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> next = head2-&gt;next;</span><br><span class="line">        head2-&gt;next = head;</span><br><span class="line">        head = head2;</span><br><span class="line">        head2 = next;</span><br><span class="line">    }</span><br><span class="line">    tail-&gt;next = head2;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>做这些链表的题目时，其实不难，思路是正确的，但是很少能一下子pass，总是要依靠多次debug才能完整pass，我觉得解题目时分步骤coding可以大大改善这种困境。例如以上反转区间的问题，先把它分为两步：<ol><li>逆转链表的前K个节点</li><li>找到第 <code>m-1</code> 个节点</li></ol></li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><form action="/2022/05/30/链表中的节点每k个翻转" method="Get"><input type="submit" value="链表中的节点每k个一组翻转"></form>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 牛客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dos命令copy与xcopy</title>
      <link href="/2022/05/29/dos%E5%91%BD%E4%BB%A4copy%E4%B8%8Excopy/"/>
      <url>/2022/05/29/dos%E5%91%BD%E4%BB%A4copy%E4%B8%8Excopy/</url>
      
        <content type="html"><![CDATA[<h1 id="Dos命令-copy-与-xcopy"><a href="#Dos命令-copy-与-xcopy" class="headerlink" title="Dos命令 copy 与 xcopy"></a>Dos命令 copy 与 xcopy</h1><h2 id="为什么要用这两个命令"><a href="#为什么要用这两个命令" class="headerlink" title="为什么要用这两个命令"></a>为什么要用这两个命令</h2><ul><li>windows管理器中 <code>Ctrl+C</code> 然后 <code>Ctrl+V</code> 就行了，为什么还要学这两个命令？</li><li>说一个我平常会用到 这两个命令的场景<ul><li>开发的一个客户端程序 <code>A</code> 会在运行时动态加载一个 <code>B.dll</code> 在开发 <code>B.dll</code> 的时候要时常将编译好的 dll 文件手动copy到客户端程序A的运行目录，为了减少手动复制，我会在 dll项目编译后自动执行一句脚本，将 <code>B.dll</code> 复制到 A程序的运行目录 (vs项目的 BuildEvents:Post-build event command line)</li></ul></li></ul><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><ul><li><p><a href="https://home.csulb.edu/~murdock/copy.html">copy</a><sup>1</sup>：用于copy文件</p></li><li><p>查看帮助: <code>copy /?</code></p><figure class="highlight dos"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">smx</span>&gt;<span class="title">copy</span> /?</span></span><br><span class="line"><span class="function">将一份或多份文件复制到另一个位置。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">COPY</span> [/<span class="title">D</span>] [/<span class="title">V</span>] [/<span class="title">N</span>] [/<span class="title">Y</span> | /-<span class="title">Y</span>] [/<span class="title">Z</span>] [/<span class="title">L</span>] [/<span class="title">A</span> | /<span class="title">B</span> ] <span class="title">source</span> [/<span class="title">A</span> | /<span class="title">B</span>]</span></span><br><span class="line"><span class="function">     [+ <span class="title">source</span> [/<span class="title">A</span> | /<span class="title">B</span>] [+ ...]] [<span class="title">destination</span> [/<span class="title">A</span> | /<span class="title">B</span>]]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">source</span>       指定要复制的文件。</span></span><br><span class="line"><span class="function">  /<span class="title">A</span>           表示一个 <span class="title">ASCII</span> 文本文件。</span></span><br><span class="line"><span class="function">  /<span class="title">B</span>           表示一个二进位文件。</span></span><br><span class="line"><span class="function">  /<span class="title">D</span>           允许解密要创建的目标文件</span></span><br><span class="line"><span class="function">  <span class="title">destination</span>  为新文件指定目录和/或文件名。</span></span><br><span class="line"><span class="function">  /<span class="title">V</span>           验证新文件写入是否正确。</span></span><br><span class="line"><span class="function">  /<span class="title">N</span>           复制带有非 8<span class="title">dot3</span> 名称的文件时，</span></span><br><span class="line"><span class="function">               尽可能使用短文件名。</span></span><br><span class="line"><span class="function">  /<span class="title">Y</span>           不使用确认是否要覆盖现有目标文件</span></span><br><span class="line"><span class="function">               的提示。</span></span><br><span class="line"><span class="function">  /-<span class="title">Y</span>          使用确认是否要覆盖现有目标文件</span></span><br><span class="line"><span class="function">               的提示。</span></span><br><span class="line"><span class="function">  /<span class="title">Z</span>           用可重新启动模式复制已联网的文件。</span></span><br><span class="line"><span class="function">/<span class="title">L</span>           如果源是符号链接，请将链接复制</span></span><br><span class="line"><span class="function">               到目标而不是源链接指向的实际文件。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">命令行开关 /<span class="title">Y</span> 可以在 <span class="title">COPYCMD</span> 环境变量中预先设定。</span></span><br><span class="line"><span class="function">这可能会被命令行上的 /-<span class="title">Y</span> 替代。除非 <span class="title">COPY</span></span></span><br><span class="line"><span class="function">命令是在一个批处理脚本中执行的，默认值应为</span></span><br><span class="line"><span class="function">在覆盖时进行提示。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">要附加文件，请为目标指定一个文件，为源指定</span></span><br><span class="line"><span class="function">数个文件(用通配符或 <span class="title">file1</span>+<span class="title">file2</span>+<span class="title">file3</span> 格式)。</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>常用的一些选项:</p><ul><li><code>/y</code>: 覆盖不提示</li></ul></li><li><p>samples:</p><ul><li><p>将文件<code>file1</code> 复制为 <code>file2</code>, <code>file2</code> 文件不存在： <code>copy file1 file2</code></p></li><li><p>将文件 <code>file1</code> 复制为 <code>file2</code>, <code>file2</code> 文件已经存在: </p><figure class="highlight dos"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">F:\<span class="title">files</span>\<span class="title">blend</span>\<span class="title">test</span>&gt;<span class="title">copy</span> <span class="title">file1</span> <span class="title">file2</span></span></span><br><span class="line"><span class="function">覆盖 <span class="title">file2</span> 吗? (<span class="title">Yes</span>/<span class="title">No</span>/<span class="title">All</span>): <span class="title">Yes</span></span></span><br><span class="line"><span class="function">已复制         1 个文件。</span></span><br><span class="line"><span class="function"><span class="title">F</span>:\<span class="title">files</span>\<span class="title">blend</span>\<span class="title">test</span>&gt;<span class="title">copy</span> /<span class="title">y</span> <span class="title">file1</span> <span class="title">file2</span></span></span><br><span class="line"><span class="function">已复制         1 个文件。</span></span><br></pre></td></tr></tbody></table></figure><ul><li>如果想要覆盖不提示 需要添加 <code>/y</code> 参数: <code>copy /y file1 file2</code></li></ul></li><li><p>将文件 <code>file1</code> 复制到 <code>folder1</code> 目录下: <code>copy file1 folder1</code></p></li><li><p>将文件 <code>file1</code> 复制到 <code>folder1</code>目录下并命名为 <code>file2</code>: <code>copy file1 "folder1/file2"</code></p><ul><li><font color="red"><strong>note:</strong></font> 这里的 <code>"folder1/file2"</code> 必须要加上引号才行</li></ul></li></ul></li></ul><h2 id="xcopy"><a href="#xcopy" class="headerlink" title="xcopy"></a>xcopy</h2><ul><li><p><a href="https://home.csulb.edu/~murdock/xcopy.html">xcopy</a><sup>2</sup>: 可以复制文件和目录</p></li><li><p>查看帮助: <code>xcopy /?</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">F:\files\blend\test&gt;xcopy /?</span><br><span class="line">复制文件和目录树。</span><br><span class="line"></span><br><span class="line">XCOPY source [destination] [/A | /M] [/D[:date]] [/P] [/S [/E]] [/V] [/W]</span><br><span class="line">                           [/C] [/I] [/Q] [/F] [/L] [/G] [/H] [/R] [/T] [/U]</span><br><span class="line">                           [/K] [/N] [/O] [/X] [/Y] [/-Y] [/Z] [/B] [/J]</span><br><span class="line">                           [/EXCLUDE:file1[+file2][+file3]...] [/COMPRESS]</span><br><span class="line"></span><br><span class="line">  source       指定要复制的文件。</span><br><span class="line">  destination  指定新文件的位置和/或名称。</span><br><span class="line">  /A           仅复制有存档属性集的文件，</span><br><span class="line">               但不更改属性。</span><br><span class="line">  /M           仅复制有存档属性集的文件，</span><br><span class="line">               并关闭存档属性。</span><br><span class="line">  /D:m-d-y     复制在指定日期或指定日期以后更改的文件。</span><br><span class="line">               如果没有提供日期，则只复制</span><br><span class="line">               源时间比目标时间新的文件。</span><br><span class="line">  /EXCLUDE:file1[+file2][+file3]...</span><br><span class="line">               指定含有字符串的文件列表。每个字符串</span><br><span class="line">               在文件中应位于单独的一行。如果任何</span><br><span class="line">               字符串与复制文件的绝对路径的任何部分相符，</span><br><span class="line">               则排除复制该文件。例如，</span><br><span class="line">               指定如 \obj\ 或 .obj 的字符串会分别</span><br><span class="line">               排除目录 obj 下面的所有文件或带有</span><br><span class="line">               .obj 扩展名的所有文件。</span><br><span class="line">  /P           创建每个目标文件之前均进行提示。</span><br><span class="line">  /S           复制目录和子目录，不包括空目录。</span><br><span class="line">  /E           复制目录和子目录，包括空目录。</span><br><span class="line">               与 /S /E 相同。可以用来修改 /T。</span><br><span class="line">  /V           验证每个新文件的大小。</span><br><span class="line">  /W           提示在复制前按键。</span><br><span class="line">  /C           即使有错误，也继续复制。</span><br><span class="line">  /I           如果目标不存在，且要复制多个文件，</span><br><span class="line">               则假定目标必须是目录。</span><br><span class="line">  /Q           复制时不显示文件名。</span><br><span class="line">  /F           复制时显示完整的源文件名和目标文件名。</span><br><span class="line">  /L           显示要复制的文件。</span><br><span class="line">  /G           允许将加密文件复制到</span><br><span class="line">               不支持加密的目标。</span><br><span class="line">  /H           隐藏文件和系统文件也会复制。</span><br><span class="line">  /R           覆盖只读文件。</span><br><span class="line">  /T           创建目录结构，但不复制文件。不</span><br><span class="line">               包括空目录或子目录。/T /E 包括</span><br><span class="line">               空目录和子目录。</span><br><span class="line">  /U           只复制已经存在于目标中的文件。</span><br><span class="line">  /K           复制属性。一般的 Xcopy 会重置只读属性。</span><br><span class="line">  /N           用生成的短名称复制。</span><br><span class="line">  /O           复制文件所有权和 ACL 信息。</span><br><span class="line">  /X           复制文件审核设置(隐含 /O)。</span><br><span class="line">  /Y           取消提示以确认要覆盖</span><br><span class="line">               现有目标文件。</span><br><span class="line">  /-Y          触发提示，以确认要覆盖</span><br><span class="line">               现有目标文件。</span><br><span class="line">  /Z           在可重新启动模式下复制网络文件。</span><br><span class="line">  /B           复制符号链接本身与链接目标。</span><br><span class="line">  /J           复制时不使用缓冲的 I/O。推荐复制大文件时使用。</span><br><span class="line">  /COMPRESS    如果适用，在传输期间请求网络</span><br><span class="line">               压缩。</span><br><span class="line"></span><br><span class="line">开关 /Y 可以预先在 COPYCMD 环境变量中设置。</span><br><span class="line">这可能被命令行上的 /-Y 覆盖。</span><br></pre></td></tr></tbody></table></figure></li><li><p>常用的一些选项: <code>/iqyes</code></p><ul><li><p><code>/y</code>：覆盖不提示，否则</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F:\files\blend\practices\copy&gt;xcopy /iqs test test1</span><br><span class="line">覆盖 F:\files\blend\practices\copy\test1\1.txt (Y:是/N:否/A:全部)?</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>/Q</code>:  复制的时候不显示文件名，否则</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F:\files\blend\practices\copy&gt;xcopy /isy test test1</span><br><span class="line">test\1.txt</span><br><span class="line">test\2.txt</span><br><span class="line">test\3.txt</span><br><span class="line">test\4.txt</span><br><span class="line">test\subfolder\sub.txt</span><br><span class="line">复制了 5 个文件</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>/I</code>:  如果目标不存在，且要复制多个文件，则假定目标是目录</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F:\files\blend\practices\copy&gt;xcopy /qs test test2</span><br><span class="line">目标 test2 是文件名</span><br><span class="line">还是目录名</span><br><span class="line">(F = 文件，D = 目录)?</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>/E</code>:  复制目录和子目录（包括空目录）</p></li><li><p><code>/S</code>:  复制目标和子目录（不包括空目录）</p></li></ul></li><li><p>samples</p><ul><li><p>将文件 <code>file1</code> 复制为 <code>file2</code> , <code>file2</code>不存在:</p><figure class="highlight dos"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">F:\<span class="title">files</span>\<span class="title">blend</span>\<span class="title">test</span>&gt;<span class="title">xcopy</span> <span class="title">file1</span> <span class="title">file2</span></span></span><br><span class="line"><span class="function">目标 <span class="title">file2</span> 是文件名</span></span><br><span class="line"><span class="function">还是目录名</span></span><br><span class="line"><span class="function">(<span class="title">F</span> = 文件，<span class="title">D</span> = 目录)? <span class="title">F</span></span></span><br><span class="line"><span class="function"><span class="title">F:file1</span></span></span><br><span class="line"><span class="function">复制了 1 个文件</span></span><br></pre></td></tr></tbody></table></figure><ul><li>因为不确定目标是文件还是目录，所以这里会提示你是文件还是目录</li></ul></li><li><p>将文件 <code>file1</code> 复制为 <code>file2</code>, <code>file2</code>文件已存在: <code>xcopy /y file1 file2</code> 这里不会提示文件还是目录，因为 <code>file2</code>文件已存在，确认是文件</p></li><li><p>将文件 <code>file1</code> 复制到 <code>folder1</code>目录下 <code>folder1</code>目录已存在：<code>xcopy /y file1 folder1</code></p></li><li><p>将文件 <code>file1</code> 复制到 <code>fodler1</code> 目录下，<code>folder1 </code>目录不存在: </p><figure class="highlight dos"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">F:\<span class="title">files</span>\<span class="title">blend</span>\<span class="title">test</span>&gt;<span class="title">xcopy</span> <span class="title">file1</span> <span class="title">folder1</span></span></span><br><span class="line"><span class="function">目标 <span class="title">folder1</span> 是文件名</span></span><br><span class="line"><span class="function">还是目录名</span></span><br><span class="line"><span class="function">(<span class="title">F</span> = 文件，<span class="title">D</span> = 目录)? <span class="title">D</span></span></span><br><span class="line"><span class="function"><span class="title">F:file1</span></span></span><br><span class="line"><span class="function">复制了 1 个文件</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>将目录 <code>folder1</code> 复制为 <code>folder2</code>目录 <code>folder2</code>目录不存在: <code>xcopy /i folder1 folder2 </code></p></li><li><p>将目录 <code>folder1</code> 复制为 <code>folder2</code>目录 <code>folder2</code>目录存在: <code>xcopy /y folder1 folder2 </code></p></li><li><p>将目录 <code>folder1</code> 复制到 <code>folder2</code> 目录下并命名为 <code>test</code> 目录 : <code>xcopy /i folder1 "folder2/test"</code></p></li><li><p>将目录 <code>folder1</code> 所有内容复制到 <code>folder2/test</code>目录下， <code>folder2/test</code> 目录存在: <code>xcopy /y /q folder1 "folder2/test"</code></p></li></ul></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><p><code>[1]</code> <a href="https://home.csulb.edu/~murdock/copy.html">copy</a></p></li><li><p><code>[2]</code> <a href="https://home.csulb.edu/~murdock/xcopy.html">xcopy</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> dos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dos </tag>
            
            <tag> commands </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c程序定位段错误segment fault</title>
      <link href="/2022/05/28/c%E7%A8%8B%E5%BA%8F%E5%AE%9A%E4%BD%8D%E6%AE%B5%E9%94%99%E8%AF%AFsegment-fault/"/>
      <url>/2022/05/28/c%E7%A8%8B%E5%BA%8F%E5%AE%9A%E4%BD%8D%E6%AE%B5%E9%94%99%E8%AF%AFsegment-fault/</url>
      
        <content type="html"><![CDATA[<h1 id="c程序定位段错误segment-fault"><a href="#c程序定位段错误segment-fault" class="headerlink" title="c程序定位段错误segment fault"></a>c程序定位段错误segment fault</h1><ul><li>在编写c语言程序时，会经常不小心写出 段错误 的bug代码，但是又不知道导致段错误的代码，有小伙伴会说，可以gdb一行一行地调试啊，虽然这样是可以的，但是效率太低，接下来我会演示一下如何定位段错误的位置</li></ul><h2 id="首先要了解段错误"><a href="#首先要了解段错误" class="headerlink" title="首先要了解段错误"></a>首先要了解段错误</h2><h3 id="导致段错误的原因"><a href="#导致段错误的原因" class="headerlink" title="导致段错误的原因"></a>导致段错误的原因</h3><ul><li>一般有四种原因<ol><li>访问了非法内存: <code>int* p = NULL; printf("%d\n", *p);</code></li><li>数组越界: <code>int a[4]; a[4] = 1;</code> 数组越界存在不确定因素，有时候会出现段错误，有时候不会</li><li>scanf错误使用: <code>int a; scanf("%d", a);</code></li><li>指针访问只读内存： <code>char* str = "111"; str[0] = 'a';</code></li></ol></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul><li><p>编写代码：<code>segment.c</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    *p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>编译并运行:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos c]<span class="comment"># gcc -g segment.c</span></span><br><span class="line">[root@VM-16-5-centos c]<span class="comment"># ./a.out</span></span><br><span class="line">Segmentation fault</span><br><span class="line">[root@VM-16-5-centos c]<span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>如上所示，执行程序的时候，报段错误，但是没有生成 <code>core</code> 文件，所以需要手动设置一下 <a href="https://www.linuxcool.com/ulimit">ulimit</a><sup>1</sup> 然后再运行，并查看生成的core文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos c]<span class="comment"># ulimit -c unlimited</span></span><br><span class="line">[root@VM-16-5-centos c]<span class="comment"># ./a.out</span></span><br><span class="line">Segmentation fault (core dumped)</span><br><span class="line">[root@VM-16-5-centos c]<span class="comment"># ls</span></span><br><span class="line">a.out  core.26602  error.txt  pipe.c  read_pipe.c  segment.c  simulate_commands  write_pipe.c</span><br></pre></td></tr></tbody></table></figure></li><li><p>如上图所示中的 <code>core.26602</code> 就是生成的段错误文件，接下来我们要进入gdb来分析该 core文件定位导致段错误的位置</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos c]<span class="comment"># gdb a.out core.26602</span></span><br><span class="line">GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-120.el7</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-redhat-linux-gnu"</span>.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</span><br><span class="line">Reading symbols from /root/files/blend/gitpros/linux/coding/c/a.out...done.</span><br><span class="line">[New LWP 27251]</span><br><span class="line">Core was generated by `./a.out<span class="string">'.</span></span><br><span class="line"><span class="string">Program terminated with signal 11, Segmentation fault.</span></span><br><span class="line"><span class="string">#0  0x00000000004004fd in main () at segment.c:6</span></span><br><span class="line"><span class="string">6*p = 1;</span></span><br><span class="line"><span class="string">Missing separate debuginfos, use: debuginfo-install glibc-2.17-325.el7_9.x86_64</span></span><br><span class="line"><span class="string">(gdb) </span></span><br></pre></td></tr></tbody></table></figure></li><li><p>从以上的gdb信息就可以看到导致段错误的代码位置: </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Program terminated with signal 11, Segmentation fault.</span><br><span class="line"><span class="comment">#0  0x00000000004004fd in main () at segment.c:6</span></span><br><span class="line">6*p = 1;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><code>[1]</code> <a href="https://www.linuxcool.com/ulimit">ulimit</a></li></ul><h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h2><ul><li><code>ulimit</code></li><li><code>gdb a.out core</code></li><li><code>gcc -g segment.c</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> linux </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现linux的cat命令</title>
      <link href="/2022/05/27/%E5%AE%9E%E7%8E%B0linux%E7%9A%84cat%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/05/27/%E5%AE%9E%E7%8E%B0linux%E7%9A%84cat%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="实现linux的cat命令"><a href="#实现linux的cat命令" class="headerlink" title="实现linux的cat命令"></a>实现linux的cat命令</h1><h2 id="cat命令简介"><a href="#cat命令简介" class="headerlink" title="cat命令简介"></a>cat命令简介</h2><ul><li>首先linux的命令手册: <code>man cat</code>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat - concatenate files and print on the standard output</span><br></pre></td></tr></tbody></table></figure></li><li><a href="https://www.linuxcool.com/cat">cat</a><sup>1</sup>: 在终端设备上显示文件内容，其功能是用于查看文件内容</li></ul><h2 id="C代码实现"><a href="#C代码实现" class="headerlink" title="C代码实现"></a>C代码实现</h2><ul><li><p>首先看几个函数</p><ul><li><a href="https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm">fopen</a><sup>2</sup>: The C library function <code>FILE *fopen(const char *filename, const char *mode)</code> opens the filename pointed to, by filename using the given mode.<ul><li>打开文件，返回文件指针</li><li>example: <code>FILE* fp = fopen("test.txt", "r");</code></li></ul></li><li><a href="https://www.tutorialspoint.com/c_standard_library/c_function_fread.htm">fread</a><sup>3</sup>: The C library function size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) reads data from the given stream into the array pointed to, by ptr.<ul><li>从文件中读取字节</li><li>example: <code>int len = fread(buffer, 1, 5, fp);</code></li></ul></li><li><a href="https://www.tutorialspoint.com/c_standard_library/c_function_fprintf.htm">fprintf</a><sup>4</sup>: The C library function int fprintf(FILE *stream, const char *format, …) sends formatted output to a stream.<ul><li>格式化输出到流</li><li>examples:<ul><li>格式化输出到标准输出流: <code>fprintf(stdout, "this is standard output!\n")</code>, 相当于 <code>printf</code></li><li>格式化输出到标准错误流: <code>fprintf(stderr, "this is standard error!\n")</code></li></ul></li></ul></li><li><a href="https://www.tutorialspoint.com/c_standard_library/c_function_fclose.htm">fclose</a><sup>5</sup>: The C library function int fclose(FILE *stream) closes the stream. All buffers are flushed.<ul><li>关闭文件流</li><li>example: <code>fclose(fp)</code></li></ul></li><li><a href="https://linux.die.net/man/2/access">access</a><sup>6</sup>: access - check real user’s permissions for a file<ul><li>判断是否具有文件操作的权限</li><li>examples:<ul><li>判断文件是否存在: <code>if (access(file_path, F_OK) == 0){}</code></li><li>判断是否可以读取文件: <code>if (access(file_path, R_OK) == 0){}</code></li><li>判断是否可以写入文件: <code>if (access(file_path, W_OK) == 0){}</code></li></ul></li></ul></li><li><a href="https://man7.org/linux/man-pages/man3/getline.3.html">getline</a><sup>7</sup>: reads an entire line from stream,<ul><li>从流中读取一整行</li><li>example: <code>ssize_t read = getline(&amp;buffer, &amp;len, stdin);</code></li></ul></li></ul></li><li><p>创建 <code>mycat.c</code></p></li><li><p><code>cat</code> 命令需要接文件参数，引入参数</p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>{<span class="keyword">return</span> <span class="number">0</span>;}</span><br></pre></td></tr></tbody></table></figure></li><li><p>判断参数的个数，如果小于等于1个参数需要按行输出用户的输入</p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// take user's input and output it by line</span></span><br><span class="line"><span class="type">char</span>* line;</span><br><span class="line"><span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="type">ssize_t</span> read;</span><br><span class="line"><span class="keyword">while</span> ((read = getline(&amp;line, &amp;len, <span class="built_in">stdin</span>) != <span class="number">-1</span>))</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, line);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (line)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">free</span>(line);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>定义一个专门显示文件内容的函数</p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">show_file_content</span><span class="params">(<span class="type">char</span>* file_path)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (access(file_path, R_OK) == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        FILE* fp = fopen(file_path, <span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">char</span> buffer[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (len = fread(buffer, <span class="number">1</span>, <span class="number">4</span>, fp))</span><br><span class="line">            {</span><br><span class="line">                buffer[len] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, buffer);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"file open error\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"mycat: 1: No such file or directory\n"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>接下来是main函数的调用:</p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">        {</span><br><span class="line">            show_file_content(argv[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// take user's input and output it</span></span><br><span class="line">        <span class="type">char</span>* line;</span><br><span class="line">        <span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ssize_t</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = getline(&amp;line, &amp;len, <span class="built_in">stdin</span>) != <span class="number">-1</span>))</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s"</span>, line);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (line)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">free</span>(line);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>全部代码: <code>mycat.c</code></p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_file_content</span><span class="params">(<span class="type">char</span>* file_path)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (access(file_path, R_OK) == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        FILE* fp = fopen(file_path, <span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">char</span> buffer[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (len = fread(buffer, <span class="number">1</span>, <span class="number">4</span>, fp))</span><br><span class="line">            {</span><br><span class="line">                buffer[len] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, buffer);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"file open error\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"mycat: 1: No such file or directory\n"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">        {</span><br><span class="line">            show_file_content(argv[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// take user's input and output it</span></span><br><span class="line">        <span class="type">char</span>* line;</span><br><span class="line">        <span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ssize_t</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = getline(&amp;line, &amp;len, <span class="built_in">stdin</span>) != <span class="number">-1</span>))</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s"</span>, line);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (line)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">free</span>(line);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ul><li>先编译: <code>gcc mycat.c -o mycat</code></li><li>无参数运行: <code>./mycat</code> <code>Ctrl + D</code> 结束输入  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-5-centos simulate_commands]# ./mycat</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">my name is smx</span><br><span class="line">my name is smx</span><br><span class="line">how are you today</span><br><span class="line">how are you today</span><br><span class="line">bye</span><br><span class="line">bye</span><br></pre></td></tr></tbody></table></figure></li><li>带参数运行: <code>./mycat 1.txt 2.txt</code></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><code>[1]</code> <a href="https://www.linuxcool.com/cat">cat命令详细介绍</a></li><li><code>[2]</code> <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm">fopen c函数</a></li><li><code>[3]</code> <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fread.htm">fread c函数</a></li><li><code>[4]</code> <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fprintf.htm">fprintf c函数</a></li><li><code>[5]</code> <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fclose.htm">fclose c函数</a></li><li><code>[6]</code> <a href="https://linux.die.net/man/2/access">access c函数</a></li><li><code>[7]</code> <a href="https://man7.org/linux/man-pages/man3/getline.3.html">getline c函数</a></li></ul><h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h2><ul><li>c函数<ul><li><code>fopen</code>、<code>fread</code>、<code>fprintf</code>、<code>fclose</code>、<code>access</code>、 <code>getline</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
